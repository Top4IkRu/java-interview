# Вопросы для интервью Java

## Базовый синтаксис:

1. Какие есть примитивные типы и какие у них размеры?
2. Почему 0.1 + 0.7 != 0.8? (float 0.9+0.7 считает с погрешностью, double почти все)
3. Что такое char? Почему над ним можно выполнять арифметические операции?
4. Какие есть виды приведения типов?
5. В каком случае компилятор не может сделать приведение сам и просит сделать приведение программиста?
6. Какие есть классы-обертки?
7. Зачем нужны классы-обертки? Immutable ли обертки?
8. Что такое unboxing(распаковка), autoboxing(автоупаковка) в обертках.
9. Если при распаковке обертка была равна `null`, произойдет исключение `java.lang.NullPointerException`?
10. Может ли примитив быть `null`? Что такое литерал?
11. Что такое `String Pool` (пул строк) и `Primitive Pool` (пул примитивов)?
12. Integer a = 100; Integer b = 100; System.out.println(b == a); Какой результат будет?
13. Почему не рекомендуются множественные конкатенации `String`?
14. Разница между `String`, `StringBuilder` (Java 1.5) и `StringBuffer`(Java 1.0)?
15. Что такое массив, какие на нём есть ограничения?
16. Существуют ли многомерные массивы в java? Как создать многомерный массив?
17. Что такое метод и чем отличается от функции, возвращаемое значение, аргументы метода?
18. Что такое инкремент и декремент?
19. Чем отличаются постфиксная и префиксная форма?
20. Какие есть логические операции?
21. А если подряд три true XOR true XOR true какой результат?
22. Расскажи про все условные операторы?
23. Можно ли в switch case использовать String, Enum?
24. Какие есть циклы в Java? Чем отличаются друг от друга? (пост условие пред условие)
25. Что такое continue и break? Почему не рекомендуется их использовать?
26. Если в case не поставить break что будет?
27. Что такое рекурсия? Недостатки и преимущества?
28. Зачем нужны BigInteger и BigDecimal?

## ООП

1. Что такое ООП? В чем его плюсы?
2. Перечислите основные принципы ООП (3 штуки) без объяснений?
3. Что такое инкапсуляция? Приведите пример инкапсуляции?
4. Что такое полиморфизм? Приведите пример полиморфизма?
5. Что такое наследование? Приведите пример наследования? Зачем оно нужно?
6. Что такое класс? Объект?
7. Передача параметров по ссылке или по значению?
8. Как передаются объекты в метод?
9. Что будет если передать массив в метод, который изменит его значения, изменятся ли они вне метода? Почему? А если
   передать примитив?
10. Что такое переопределение метода в Java?
11. Что такое перегрузка метода в Java?
12. Что такое нативные методы, их плюсы и минусы?
13. Перечислите все модификаторы доступа в порядке уменьшения закрытости, какую область видимости они имеют?
14. Что такое final?
15. Что может быть final? Как они работают?
16. Как реализована неизменность String?
17. Как реализовать свой Immutable тип данных?
18. Что такое ключевое слово static? Что может быть static? Можно ли использовать статические методы в обычных?
    Наоборот? Почему?
19. Может ли статический метод быть перегружен?
20. Будет ли работать переопределение статического метода?
21. Могут ли нестатические методы перегрузить статические?
22. Что такое пакет? Как создать пакет?
23. Что такое конструкторы? Конструктор по-умолчанию?
24. Будет ли в классе конструктор и какой, если при его создании ни один не был задан?
25. Будет ли создан автоматически конструктор по-умолчанию, если в созданном классе есть любой другой конструктор?
26. Можно ли в классе вызвать один конструктор из другого? Как это сделать?
27. Как вызвать конструктор родителя?
28. Расскажи, что такое this и super? Когда мы обязаны использовать this и super?
29. Класс Object, все методы кроме wait, notify, notifyAll, назвать и объяснить, как работают
30. Зачем нужен метод finalize?
31. Какой контракт между equals и hashcode? Из-за чего происходят коллизии?
32. Почему нельзя написать hashcode гарантировано без коллизий?
33. В чём разница между instanceOf и getClass?
34. Перечислите методы именно класса Enum?
35. Что такое интерфейс? Когда использовать интерфейс? Можно ли создать поля в интерфейсе?
36. Есть ли в Java множественное наследование классов?
37. Что дает множественная реализация интерфейсов?
38. Зачем наследовать интерфейс интерфейсу?
39. Можно ли создавать статик методы в интерфейсах?
40. Что такое абстрактный метод?
41. Что такое абстрактный класс? Чем отличается от обычного?
42. Может ли быть абстрактный класс без абстрактных методов?
43. Может ли быть конструктор у абстрактного класса? Для чего?
44. Синтаксические отличия интерфейса от абстрактного класса (АК)? 5 отличий

## Коллекции

1. Что такое коллекции (`Collection`) в Java? Какие основные интерфейсы коллекций вы знаете? Нарисуйте иерархию классов
   коллекций.
2. В чем разница между `List`, `Set` и `Map`?
3. Что такое `ArrayList`? В чем разница между `ArrayList` и `LinkedList`? Когда лучше использовать ArrayList, а когда
   LinkedList?
4. В чём разница между `Queue` и `Deque` и `Stack`?
5. Отличие двусвязного и односвязного списка?
6. В чём разница между `Iterable` и `Iterator`?
7. Что такое Iterator? В каких случаях нужно использовать iterator? И почему?
8. Что такое `HashMap`? Какие основные методы доступа и модификации данных в `HashMap`?
9. Может ли `null` быть ключом в `HashMap`?
10. Как работает `HashMap`?
11. Как работает метод put под капотом?
12. Что происходит при коллизии?
13. Что такое `HashSet`? Какая особенность у `HashSet` в отношении дубликатов и порядка элементов?
14. Какие коллекции из `Java Collections Framework` потокобезопасны (`thread-safe`) по умолчанию?
15. Что такое `ConcurrentHashMap`? В чем его отличие от `HashMap`?
16. Как можно сортировать элементы в коллекциях? Какой интерфейс следует использовать для сортировки?

## Исключения

1. Что такое исключение (`Exception`) в Java? Какие проблемы они помогают обрабатывать?
2. Расскажи (нарисуй) про иерархию исключений?
3. Как создать свое исключение? Зачем создавать свои?
4. В чём разница между проверяемыми (`checked`) исключениями и непроверяемыми (`unchecked`)?
5. В чём разница с точки зрения синтаксиса и идеологическая при использовании?
6. Можно ли обработать непроверяемое исключение?
7. Можно ли в сигнатуре метода в `throws` указать непроверяемое исключение?
8. Нужно ли ловить `Error` исключения?
9. Как бросить исключение?
10. Можно ли бросить НЕ новое исключение?
11. Назовите знакомые вам исключения и когда они могут возникнуть.
12. Можно ли так написать `try { throw new Object(); }`
13. Может ли main выбрасывать исключения, что будет происходить?
14. Расскажи про информацию, которая находится внутри исключения? Как с ней работать?
15. Какую информацию можно получить из `StackTraceElement`?
16. Расскажи про конструкцию `try-catch-finally`?
17. Когда будет выполнен `finally`? Когда не будет выполнен?
18. Будет ли выполнен `finally` при `Error`?
19. Что будет если до перехода в `finally` был вызван `return`?
20. Какой `return` выполнится – если их два, один в `try`, другой в `finally`?
21. Что если в конструкции `try finally` вылетело исключение сначала в `try` а потом в `finally`? Какое исключение
    вылетит? Что будет с другим? 
22. Что такое `try-with-resources`? Как работает эта конструкция? 
23. Что такое ресурс в конструкции `try-with-resources`? 
24. Что будет если при закрытии ресурса вылетит исключение в конструкции `try-with-resources`?
25. Что такое подавленные исключения? 
26. Как достать подавленное исключение?

## Ответы

## Коллекции

### Полезные материалы по коллекциям

1. [Сложность коллекций](https://www.bigocheatsheet.com)
2. [Визуализация коллекций](https://visualgo.net/en)

### 1. Что такое коллекции (`Collection`) в Java? Какие основные интерфейсы коллекций вы знаете? Нарисуйте иерархию классов коллекций.

Коллекции (`Collection`) - это набор классов которые используются для управления и хранения данных в Java. Каждый класс
использует определенную структуру данных для более эффективной работы. Однако нужно понимать, что каждая структура
имеет свои сильные и слабые стороны.

#### Основные виды коллекций

1. `List` - упорядоченная коллекция, в которой могут быть дубликаты.
   Реализации интерфейса `List` - `ArrayList`, `LinkedList`.
2. `Set` - коллекция основной особенностью которой является отсутствие дубликатов.
   Реализации интерфейса `Set` - `HashSet`, `TreeSet`.
3. `Queue` - коллекция, которая работает в стиле очереди, добавление элементов в одном конце и извлечение из другого.
   Реализации интерфейса `Queue` -  `LinkedList`, `PriorityQueue`.
4. `Map` - ассоциативная коллекция, те элементы связаны парами "ключ-значение", каждый ключ уникален и используется для
   получения значения.
   Реализации интерфейса `Map` - `HashMap`, `TreeMap`.

![java-collection-hierarchy.webp](img/java-collection-hierarchy.webp)

### 2. В чем разница между `List`, `Set` и `Map`?

Основная разница заключается в том, когда мы должны какую коллекцию использовать и какие в них есть особенности.

`List`:

- Упорядоченная коллекция и элементы хранятся в порядке их добавления.
- Элементы могут дублироваться.
- Можно получать доступ к элементам по индексам.

`Set`:

- Элементы не могут дублироваться.
- Не гарантирует порядок хранения элементов (в отличие от `List`).
- Метод `equals()` используется для определения уникальности элементов.

`Map`:

- Ассоциативная коллекция, хранящая пары "ключ-значение".
- Ключи уникальны, и каждому ключу соответствует одно значение.
- Позволяет быстро находить значение по ключу.

### 3. Что такое `ArrayList`? В чем разница между `ArrayList` и `LinkedList`? Когда лучше использовать `ArrayList`, а когда `LinkedList`?

`ArrayList` - это реализация интерфейса `List`, которая использует обычный массив для хранения данных.
`LinkedList` - это реализация интерфейса `List`, которая использует двусвязный список для хранения данных, те каждый
объект хранит ссылку на следующий элемент.

|                             | `ArrayList`                                                                                     | `LinkedList`                                                                                                                       |
|-----------------------------|-------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------|
| Внутреннее представление:   | основан на массиве, из-за этого быстрый доступ к элементам по индексу.                          | основан на двусвязном списке, где каждый элемент содержит ссылки на следующий элемент                                              |
| Вставка и удаление          | может быть медленным, так как при добавлении/удалении из середины нужно делать пересортировку   | быстрое добавление/удаление даже в середину                                                                                        | 
| Память и производительность | потребляет менбше памяти так как хранит только объекты                                          | требует больше памяти так как хранятся не только объекты но и ссылка на следующий элемент                                          |
| Поиск элемента              | быстро ищет по индексу, а так же быстрее итерируется, так как в памяти объекты лежат по очереди | перебор и поиск по индексу занимает обно и тоже время (больше чем `ArrayList`), поскольку идет простой перебор объектов по ссылкам |

`ArrayList` подходит когда у нас больше происходит чтений или получение по индексу, чем добавлений/удалений элементов.
`LinkedList` подходит когда у нас много добавлений/удалений особенно в середину списка.

### 4. В чём разница между `Queue` и `Deque` и `Stack`?

Основное отличие между `Queue` и `Deque` и `Stack` заключается в способе добавления и извлечения данных.

1. `Queue` (Очередь) - интерфейс, который позволяет работать с данными в стиле "очереди", добавление в конец очереди и
   извлечение
   из ее начала. Метод `offer()` добавляет элемент (в конец), а метод `pool()` извлекает элемент (из начала).
2. `Deque` (Двусторонняя очередь) - интерфейс, который расширяет `Queue` и позволяет добавлять и извлекать с обоих
   концов. Методы добавления: `offerFirst()`, `offerLast()` в начало и в конец соответственно, аналогично методы
   извлечения: `pollFirst()`, `pollLast()`.
3. `Stack` (Стек) - интерфейс реализующий структуру данных стек xD. Принцип работы похож на очередь, однако добавление и
   извлечение элементов происходит с одного конца. Аналог пирамиды, где каждый новым элемент кладется на предыдущий и
   убрать можно только самый верхний (последний добавленный). Метод добавления `push()`, извлечения `pop()`.

### 5. Отличие двусвязного и односвязного списка?

Отличие заключается в том, как элементы связаны друг с другом. В односвязном списке (Singly Linked List) элемент
содержит ссылку только на
следующий элемент, а то время как в двусвязном списке (Doubly Linked List)) элемент содержит ссылку как на следующий
элемент, как и на предыдущий.

Пример элемента в односвязном списке:

```java
public class Node<T> {
    private final T value; // Значение которое мы хотим хранить
    private final Node<T> next; // Ссылка на следующий элемент
}
```

Пример элемента в двусвязном списке:

```java
public class Node<T> {
    private final T value; // Значение которое мы хотим хранить
    private final Node<T> next; // Ссылка на следующий элемент
    private final Node<T> prev; // Ссылка на предыдущий элемент
}
```

### 6. В чём разница между `Iterable` и `Iterator`?

`Iterable` показывает, что объект можно перебрать, `Iterator` фактически выполняет процесс перебора коллекции.

`Iterable` - это интерфейс, который обозначает, что объект можно перебрать (проитерироваться). В интерфейсе определен
один метод `iterator()`, который возвращает объект типа `Iterator`. Стоит отметить, что `Iterable` - это родительский
интрефейс для всех коллекций.

`Iterator` - это интерфейс реализации которого используется для перебора коллекций. Определяет несколько
методов: `hasNext()` - проверяет есть ли следующий элемент, `next()` - возвращает следующий элемент, `remove()` -
опциональный метод (не всегда поддерживается) который позволяет удалить текущий элемент.

### 7. Что такое `Iterator`? В каких случаях нужно использовать `iterator`? И почему?

`Iterator` - это интерфейс реализации которого используется для перебора коллекций. Определяет несколько методов:

* `hasNext()` - проверяет есть ли следующий элемент
* `next()` - возвращает следующий элемент
* `remove()` - опциональный метод (не всегда поддерживается) который позволяет удалить текущий элемент

#### Когда нужно использовать `Iterator`?

* Последовательный перебор элементов в коллекции.
* Безопасное удаление элементов во время перебора.
* Снижение зависимости от конкретной реализации.

### 8. Что такое `HashMap`? Какие основные методы доступа и модификации данных в `HashMap`?

`HashMap` - это одна из реализаций `Map`, которая представляет собой ассоциативный массив ("ключ-значение"). Каждый
элемент храниться под каким-то ключом, что позволяет быстро находить значение по ключу.

#### Методы

1. `put(key, value)` - добавляет значение(`value`) по ключу (`key`), если ключ уже существует, значение будет
   перезаписано.
2. `get(key)` - получение значения по ключу, если ключа нет в мапе, то возвращается null.
3. `remove(key)` - удаление по указанному ключу.
4. `containsKey(key)` - проверка наличие ключа в мапе.
5. `containsValue(value)` - проверка наличия значения в мапе.
6. `size()` - возвращает количество пар ("ключ-значени") в мапе.
7. `isEmpty()` - проверяет есть ли что-то в мапе.

### 9. Может ли `null` быть ключом в `HashMap`?

Да, `null` может использоваться в качестве ключа для `HashMap`.

### 10. Как работает `HashMap`?

`HashMap` внутри себя содержит массив, каждый элемент массива мы будем называть корзина (bucket).
Каждый раз при добавлении элемента (`put(key, value)`) рассчитывается хэш для ключа (`key.hashCode()`) и на
основании этого хэша мы понимаем в какую корзину нужно добавлять значение (для этого хэш / размер массива). После
этого мы проверяем лежит ли что-то уже в этой корзине, если нет то добавляем. Если в корзине уже что-то лежит (это
называется коллизия), то в корзине образуется связанный список (linked list) и мы идем по этому списку и проверяем есть
ли элемент с таким же ключом или нет. Если элемента с таким же ключом нет, то мы просто добавим наше значение в конец
списка, если есть, то мы его перепишем.

Аналогичные действия мы делаем для поиска и удаления.
Если мы ищем по ключу, то рассчитываем хэш и в нужной корзине проверяем все элементы по ключу, если ничего не нашли
возвращаем `null`. При удалении мы определяем корзину по ключу и в ней пытаемся найти элемент с нужным ключом и удаляем
его.

Упрощенная реализация `HashMap`:

```java
public class HashMap {
    // Класс, который храниться как элемент корзины 
    class Node<K, V> {
        final K key; // ключ
        V value; // значение
        Node<K, V> next; // ссылка на следующий элемент
    }

    Node<K, V>[] buckets;

    public V put(K key, V value) {
        int hashCode = key.hashCode();
        int bucketIndex = hashCode / buckets.length - 1;

        // если в корзине ничего нет, то просто добавляем элемент
        if (buckets[bucketIndex] == null) {
            buckets[bucketIndex] = new Node<K, V>(hashCode, key, value, null);
        } else {
            Node<K, V> node = buckets[bucketIndex];

            while (node.next != null) {
                // ищем элемент с таким же ключом
                if (node.key == key) {
                    node.value = value; // заменяем значени по ключу
                    return value;
                }
                node = node.next;
            }

            // Если мы прошли по всем жлементам и не нашли с таким же ключом, то добавляем в конец
            Node<K, V> newNode = new Node<K, V>(hashCode, key, value, null);
            node.next = newNode; // не забываем добавить ссылку на новый элемент
        }
        return value;
    }

    public V get(K key) {
        int hashCode = key.hashCode();
        int bucketIndex = hashCode / buckets.length - 1;
        Node<K, V> node = buckets[bucketIndex];
        while (node != null) {
            // если нашлю элемент по ключу возвращаем его
            if (node.key == key) return node.value;
            node = node.next;
        }
        // если мы перебрали все элементы, но не нашли элемент с таким ключом, то возвращаем null
        return null;
    }

    public V remove(K key) {
        int hashCode = key.hashCode();
        int bucketIndex = hashCode / buckets.length - 1;
        Node<K, V> prev = null; // тут будем хранить элемент идущий до удаляемого
        Node<K, V> node = buckets[bucketIndex];
        while (node != null) {
            // если нашлю элемент по ключу
            if (node.key == key) {
                if (prev == null) {
                    // хотим удалить первый элемент
                    buckets[bucketIndex] = node.next;
                } else {
                    // хотим удалить не первый
                    // До удаления: 1 -> 2(prev) -> 3 (удаляем) -> null
                    // После: 1 -> 2(prev) -> null
                    prev.next = node.next;
                }
                return node.value;
            }
            prev = node; // сохраняем текущий элемент как предыдущий
            node = node.next; // переключаемся на следующий
        }
        // если мы перебрали все элементы, но не нашли элемент с таким ключом, то возвращаем null
        return null;
    }
}
```

Дополнительные материалы:

1. https://www.youtube.com/watch?v=c3RVW3KGIIE&ab_channel=Ranjithramachandran
2. https://habr.com/en/articles/128017/

### 11. Как работает метод put под капотом?

Каждый раз при добавлении элемента (`put(key, value)`) рассчитывается хэш для ключа (`key.hashCode()`) и на
основании этого хэша мы понимаем в какую корзину нужно добавлять значение (для этого хэш / размер массива). После
этого мы проверяем лежит ли что-то уже в этой корзине, если нет то добавляем. Если в корзине уже что-то лежит (это
называется коллизия), то в корзине образуется связанный список (linked list) и мы идем по этому списку и проверяем есть
ли элемент с таким же ключом или нет. Если элемента с таким же ключом нет, то мы просто добавим наше значение в конец
списка, если есть, то мы его перепишем.

Смотри пример выше с упрощенной реализацией `HashMap`

### 12. Что происходит при коллизии?

Коллизия - это ситуация при которой разным ключам соответствует один и тот же `hashCode` и вследствие этого оба объекта
будут храниться в одном и том же бакете (ячейке массива). Коллизия происходит из-за того, что хэшкод это число
типа `int` у которого есть ограничения. При коллизии в `HashMap` в одном бакете (ячейке массива) будет храниться не один
элемент, а связанный список из элементов с одинаковыми хэш-кодами.

В среднем случае коллизии не так страшны, поскольку в одном бакете храниться не слишком много элементов. Однако в худшем
случае, когда все элементы хранятся в одном бакете мы теряем все преимущества `HashMap` и получаем просто связанный
список (`LinkedList`).

### 13. Что такое `HashSet`? Какая особенность у `HashSet` в отношении дубликатов и порядка элементов?

`HashSet` - это одна из реализаций интерфейса `Set`, которая под капотом использует `HashMap` и в качестве значения
для `HashMap`использует дефолтный объект. Другими словами `HashSet` может быть заменен на `HashMap`, где ключами будут
значения которые вы хотите сохранить, а в качестве объекта будет константа.

#### Какая особенность у `HashSet` в отношении дубликатов и порядка элементов?

`HashSet` гарантирует уникальность элементов, при попытке добавить дубликат, новый элемент не будет добавлен.
`HashSet` не гарантирует никакой порядок, поскольку под капотом используется `HashMap` распределение элементов
происходит п хэшкоду из-за чего порядок добавления и извлечения могут отличаться (и в 99.(9)% будут разными xD).

### 14. Какие коллекции из `Java Collections Framework` потокобезопасны (`thread-safe`) по умолчанию?

Для начала давайте разберемся с термином "потокобезопасный". Потокобезопасность означает, что когда с коллекцией
работает не один, а сразу n потоков она будет работать точно так же как для одного потока и не будет возникать
"неожиданных" результатов.

Пример: В коллекции 100 элементов и я хочу найти 10 из них, то я могу искать по очереди 10 раз, но это может быть долго.
Тогда я могу запустить 10 потоков, которые будут в один и тот же момент времени искать каждый свое элемент.
Если результаты обоих подходов всегда будут одинаковы, то коллекция потокобезопасна.

#### Потокобезопасные коллекции по-умолчанию (из коробки):

1. `Vector` - это аналог `ArrayList`, но все методы помечены ключевым словом `synchronized`, что и обеспечивает
   потокобезопасность.
2. `Hashtable` - это аналог `HashMap`, но все методы помечены ключевым словом `synchronized`.

### 15. Что такое `ConcurrentHashMap`? В чем его отличие от `HashMap`?

`ConcurrentHashMap` - это реализация интерфейса `Map` из пакета `java.util.concurrent`, которая обеспечивает безопасную
работу в многопоточной среде. Основное отличие от `HashMap` заключается в том, что `HashMap` никак не обеспечивает
потокобезопасность, а в `ConcurrentHashMap` есть механизмы синхронизации.

Как происходит обеспечение потокобезопасности в разных реализациях `Map`:

1. `HashMap` вообще никак не обеспечивает потокобезопасность, поэтому могут возникать неожиданные результат если с ней
   работает сразу несколько потоков. Не рекомендуется использовать в многопоточной среде.
2. В `Hashtable` все методы помечены ключевым словом `synchronized`, поэтому в любой момент времени с этой коллекцией
   может работать только один поток, из-за этого производительность низкая в многопоточной среде.
3. `SynchronizedMap` - это просто обертка вокруг `Map`, в которой все методы помечены ключевым словом `synchronized`.
4. В `ConcurrentHashMap` все бакеты (ячейки массива) разделены на сегменты и доступ к каждому сегменту контролируется
   своим локом (объект для синхронизации). Другими словами если у вас 16 бакетов, которые разбиты на 4 сегмента, то в
   один момент времени могут работать по 1 потоку в каждом сегменте и они никак не будут конфликтовать. Из-за разбиения
   на сегменты мы улучшаем производительность коллекции, так как сразу несколько потоков могут безопасно работать с ней.

Картинка отлично иллюстрирующая отличия:
![map-synchronization-process.jpg](img/map-synchronization-process.jpg)
https://codepumpkin.com/hashtable-vs-synchronizedmap-vs-concurrenthashmap/

### 16. Как можно сортировать элементы в коллекциях? Какой интерфейс следует использовать для сортировки?

Для начала нужно понимать, что не все коллекции можно отсортировать.

1. Все реализации `List` могут быть отсортированы, для этого мы можем использовать метод `sort(Comparator<V> c)` в
   который передать `Comparator`.
2. `HashSet` не может быть отсортирован из-за того как он работает под капотом. `TreeSet` может быть использован, если
   нужно обеспечить уникальность элементов и их порядок. `TreeSet` использует естественный порядок или
   переданный `Comparator`.
3. `HashMap` не может быть отсортирован из-за того как он работает под капотом. `TreeMap` сортирует элементы при
   добавлении. `TreeMap` использует естественный порядок или переданный `Comparator`.

P.S. `Comparator` - это интерфейс, который позволяет задавать способ сравнения объектов.

## Исключения

### 1. Что такое исключение (`Exception`) в Java? Какие проблемы они помогают обрабатывать?

Исключение (`Exception`) - это объект, который представляет ошибку во время выполнения программы. Благодаря исключениям
мы как разработчики может контролировать поведение нашей программы если что-то пошло не так.

Во время работы программы могут возникать неожиданные проблемы такие как деление на ноль, обращение к не существующему
файлу или ошибка при соединении с сервером, все эти проблемы могут приводить к завершению программы. Однако благодаря
исключениям мы можем обработать ошибку и определить, что должно происходить если она случилась.

### 2. Расскажи (нарисуй) про иерархию исключений?

* Throwable (`checked`) - это базовый класс для всех исключений.
* Error (`unchecked`) - критические ошибки с которыми программа, в основном, ничего сделать не может.
  Распространенные: `OutOfMemoryError` или `StackOverflowError`.
* Exception (`checked`) - не критические ошибки, которые могут быть обработаны программой.
  Распространенные: `RuntimeException` или `IOException`.
* RuntimeException (`unchecked`) - подкатегория не проверяемых исключений (`Exception`).
  Распространенные: `NullPointerException`, `ArrayIndexOutOfBoundsException` и т.д.

![exceptions-hierarchy.png](img/exceptions-hierarchy.png)

[Источник изображения на сайте javastudy](https://javastudy.ru/interview/exceptions/)

### 3. Как создать свое исключение? Зачем создавать свои?

Для того чтобы создать свое исключение, нужно создать новый класс, который будет наследовать `Exception` (или другое
исключение).

```java
// Создаем пользовательское исключение
class CustomException extends Exception {
    public CustomException(String message) {
        super(message);
    }
}
```

Пользовательское исключение может помочь в отладке программы, поскольку может содержать дополнительную информацию, а
также возникать только в определнных случаях, о которых разработчики знают. К примеру у вас может быть свое исключение,
которое создается только при ошибке подключения к серверу базы данных. И когда вы увидете это исключение вы сразу будете
знать в чем проблема.

### 4. В чём разница между проверяемыми (`checked`) исключениями и непроверяемыми (`unchecked`) ?

Основное отличие заключается в том нужно ли проверять исключение или нет ( название говорит само за себя =) ).

* Непроверяемые (`unchecked`) исключения, которые не требуют обязательной обработки или объявления в сигнатуре метода.

* Проверяемые (`checked`) исключения должны быть указаны в сигнатуре метода. Если метод вызывает другой метод, который
  может вернуть проверяемое исключение (см пример ниже), то есть всего два варинта. Первый: мы должны обработать
  исключение с помощью try-catch или же второй вариант прокинуть ошибку выше и при этом указать ее в сигнатуре

```java
public class Example {

    // Вариант 1
    public void methodOne() throws FileNotFoundException {
        methodWithCheckedException();
    }

    public void methodTwo() {
        try {
            methodWithCheckedException();
        } catch (Exception e) {
            System.out.println("КАТАСТРОФА!! Мы не нашли такой файл");
        }
    }

    public void methodWithCheckedException() throws FileNotFoundException {
        throw new FileNotFoundException();
    }
}
```

### 5. В чём разница с точки зрения синтаксиса и идеологическая при использовании?

| Отличие   | Проверяемое исключение (`checked`)                                                                    | Непроверяемое исключение (`unchecked`)                                                     |
|-----------|-------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|
| Синтаксис | Должны быть либо обработаны с помощью `try-catch`, либо указаны в сигнатуре метода с помощью `throws` | Ничего делать не надо                                                                      |
| Назначени | Обычно это исключения которые могут произойти не по виде программиста и должны быть обработаны        | Обычно указывают на ошибку в коде, которую можно исправить (Пример `NullPointerException`) |

### 6. Можно ли обработать непроверяемое исключение?

Да, с помощью блока `try-catch` мы можем перехватить и обработать непроверяемое исключение. Однако нужно понимать, что
непроверяемое исключение обычно указывает на проблему в коде, которую допустил программист, и такие проблемы должны не
обрабатываться, а решаться исправлением кода.

### 7. Можно ли в сигнатуре метода в `throws` указать непроверяемое исключение?

Да, мы можем указать непроверяемое исключение в сигнатуре метода, однако это не наложит никаких дополнительных
ограничений. Мы можем не указывать это исключение в остальных методах, а также не должны его обрабатывать.

```java
public class UncheckedExceptionExample {
    public static void main(String[] args) {
        someMethod();
    }

    public static void someMethod() throws NullPointerException {
        int[] arr = null;
        System.out.println(arr.length); // Вызовет NullPointerException
    }
}
```

### 8. Нужно ли ловить `Error` исключения?

Нужно избегать ловить `Error`, поскольку этот тип исключений отвечает за критические ошибки в состоянии JVM или внешними
факторами с которыми программа не в состоянии справиться сама. Вы можете поймать это исключение, но в большинстве
случаев не сможете разрешить.

Примеры `Error`:

* `OutOfMemoryError` - программа исчерпала доступную память.
* `StackOverflowError` - стек вызовов переполнен из-за глубокой рекурсии.

### 9. Как бросить исключение?

Для того чтобы бросить исключение, нужно использовать ключевое слово `throw`.

```java
class Example {

    public void throwException() {
        throw new RuntimeException('Test exception!');
    }
}
```

### 10. Можно ли бросить НЕ новое исключение?

Да, если вы поймали исключение блоком `catch` и не знаете как его обработать, вы можете его пробросить выше используя
ключевое слово `throw`.

```java
class Example {

    // Метод где мы можем справиться с ошибкой
    public void methodOne() {
        try {
            methodTwo();
        } catch (Exception e) {
            System.out.println("Обработка RuntimeException исключения");
        }
    }

    // Метод где мы не знаем как обработать RuntimeException
    public void methodTwo() {
        try {
            throwException();
        } catch (Exception e) {
            if (e instanceof RuntimeException) {
                throw e;
            } else {
                System.out.println("Обработка исключения...");
            }
        }
    }

    public void throwException() {
        throw new RuntimeException('Test exception!');
    }
}
```

### 11. Назовите знакомые вам исключения и когда они могут возникнуть.

1. `NullPointerException` - возникает при обращении к объекту или вызове метода на переменной которая содержит
   значение `null`.
2. `ArrayIndexOutOfBoundsException` - возникает при обращении по индексу в массиве, которых больше размера массива.
3. `FileNotFoundException` - возникает, если мы пытаемся открыть файл которого нет или у нас нет доступа к нему.
4. `IOException` - возникает когда есть проблемы с чтением или записью данных.
5. `ArithmeticException` - возникает при арифметических ошибках (например, делении на ноль).
6. `ClassCastException` - возникает при неправильном приведении типов (например, при попытке привести объект к классу,
   которым он не является).
7. `OutOfMemoryError` - возникает, когда программа исчерпала доступную память.
8. `StackOverflowError` - возникает, когда стек вызовов переполняется из-за глубокой рекурсии.

### 12. Можно ли так написать `try { throw new Object(); }`

Нет так написать нельзя, мы получим ошибку компиляции, поскольку после `throw` должен идти объект типа `Throwable`.

### 13. Может ли main выбрасывать исключения, что будет происходить?

Да мы можем в main выбросить исключение. Если мы его перехватим и обработаем с помощью `try-catch`, то программа
продолжит работать дальше. Однако если мы его не перехватим, то программа завершиться с ошибкой.
Стоит отметить, что проверяемые (`checked`) исключения должны быть объявлены в сигнатуре метода main

```java
public class Example {
    // не забываем объявить проверяемое исключение в сигнатуре метода
    public static void main(String[] args) throws IOException {
        throw new IOException("Исключение в методе main");
    }
}
```

### 14. Расскажи про информацию, которая находится внутри исключения? Как с ней работать?

Исключения содержат в себе информацию о том, какая ошибка и где произошла, а также могут содержать дополнительные
сведения о том, какие условия привели к ошибке.

* Сообщение об ошибке (message) - текстовое сообщение с объяснением ошибки.
* Стек вызовов (stack trace) - упорядоченный список методов которые были вызваны до момента когда произошла ошибка

### 15. Какую информацию можно получить из `StackTraceElement`?

Объект `StackTraceElement` представляет элемент в стеке вызовов (stack trace). Из него можно получить:

1. Имя файла в котором лежит вызываемый метод. Метод: `getFileName()`.
2. Имя класса где был вызван метод. Метод: `getClassName()`.
3. Имя вызываемого метода. Метод: `getMethodName()`.
4. Номер строки на которой находится вызываемый метод. Метод: `getLineNumber()`.

### 16. Расскажи про конструкцию `try-catch-finally`?

`try-catch-finally` - это конструкция, которая используется в Java для обработки исключений.
В блоке `try` мы можем выполнять код, который потенциально может выбросить исключение.
В блоке `catch` мы можем указать какие исключения мы хотим перехватывать и как их нужно обработать.
В блоке `finally` мы можем написать код, который будет выполнен не зависимо от того было ли исключение или нет.

```java
public class Example {
    public static void main(String[] args) {
        try {
            int result = divide(10, 0);
            System.out.println("Результат: " + result);
        } catch (ArithmeticException e) {
            System.out.println("Произошла ошибка: " + e.getMessage());
        } finally {
            System.out.println("Блок finally выполнен всегда");
        }
    }

    public static int divide(int a, int b) {
        return a / b;
    }
}
```

### 17. Когда будет выполнен `finally`? Когда не будет выполнен?

Блок `finally` будет выполнен после блока `try` если исключения не было или же после блока `catch` если оно произошло.
Стоит отметить несколько причин по которым блок `finally` может не выполняться.

1. Если был вызван метод для завершения программы: `System.exit()`.
2. Если в блоке `try` или `catch` бесконечный цикл, который никогда не завершиться.

### 18. Будет ли выполнен `finally` при `Error`?

Да, блок `finally` будет выполнен даже при возникновении `Error`

```java
public class FinallyWithErrorExample {
    public static void main(String[] args) {
        try {
            throw new StackOverflowError("Пример ошибки");
        } finally {
            System.out.println("Блок finally выполнен, даже при Error");
        }
    }
}
```

### 19. Что будет если до перехода в `finally` был вызван `return`?

Если в блоке `try` или `catch` был вызван `return`, то блок `finally` будет вызван в любом случае.

### 20. Какой `return` выполнится – если их два, один в `try`, другой в `finally`?

Результат блока `finally` будет всегда "главнее" чем результат работы блока `try` или `catch`. Давайте рассмотрим на
примере.

```java
class Scratch {
    public static void main(String[] args) {
        System.out.println(testMethod()); // Выведет: 11
    }

    public static int testMethod() {
        try {
            return 10;
        } finally {
            System.out.println("Блок finally выполнен");
            return 11;
        }
    }
}
```

### 21. Что если в конструкции `try finally` вылетело исключение сначала в `try` а потом в `finally`? Какое исключение вылетит? Что будет с другим?

Как мы обсуждали в прошлом вопросе, результат `finally` всегда "главнее" результат блоков `try` или `catch`. Абсолютно
такая же логика и с исключениями. Если сначала было исключение в блоке `try` или `catch`, а потом в блоке `finally`, как
результата мы увидим исключение из `finally`, а исключения из блока `try` или `catch` будут "подавлены". Поскольку
считается, что ошибка в `finally` критичнее чем в `try` или `catch`.

```java
class Example {
    public static void main(String[] args) {
        try {
            testMethod();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    public static int testMethod() {
        try {
            throw new RuntimeException("Exception from try block!");
        } finally {
            throw new RuntimeException("Exception from finally block!");
        }
    }
}
```


### 22. Что такое `try-with-resources`? Как работает эта конструкция?

`try-with-resources` - это конструкция, использующаяся когда нам нужно поработать с ресурсами, которые должны быть
закрыты в конце. Благодаря этой конструкции мы можем не беспокоиться о том, что мы не закроем вручную какие-то ресурсы,
поскольку они закроются автоматически.
Стоит отметить, что ресурсы должны реализовывать интерфейс `java.lang.AutoCloseable`, в котором декларируется всего один
метод `close()`. Этот метод и будет вызван для закрытия ресурсов.

Синтаксис

```
try (ресурс_1_инициализация; ресурс_2_инициализация; ...) {
    // Код, использующий ресурсы
} catch (исключение) {
    // Обработка исключения
}
```

Пример:

```java
class Example {
    public class TryWithResourcesExample {

        public static void main(String[] args) {
            try (MyResource resource = new MyResource()) {
                resource.doSomething();
            } catch (Exception e) {
                System.out.println("Произошла ошибка: " + e.getMessage());
            }
        }
    }

    static class MyResource implements AutoCloseable {
        public void doSomething() throws Exception {
            System.out.println("Выполняем действия с ресурсом");
            throw new Exception("Пример ошибки");
        }

        @Override
        public void close() throws Exception {
            System.out.println("Ресурс закрыт");
        }
    }
}
```

### 23. Что такое ресурс в конструкции `try-with-resources`?

Ресурс - это объект, который реализует интерфейс `java.lang.AutoCloseable` или `java.io.Closeable`.
Ресурс - это объект с которым мы хотим поработать и после корректно его закрыть, чтобы не допустить утечек памяти и
обеспечить правильное освобождение ресурсов.

### 24. Что будет если при закрытии ресурса вылетит исключение в конструкции `try-with-resources`?

Если блок `try` завершается корректно, то мы просто увидим исключение полученное при закрытии ресурса. Но если
блок `try` упал с ошибкой и произошла ошибка при закрытии ресурсов, то мы увидим ошибку из блока `try`, а ошибка при
закрытии ресурсов будет "подавлена". Это сделано для того, чтобы мы не упустили "важную" ошибку из блока `try`.
Подавленные ошибки можно получить с помощью метода `getSuppressed()`.

Пример с корректным завершением блока `try`:

```java
class Example {
    public static void main(String[] args) {
        try (MyResource resource = new MyResource()) {
            resource.doSomething();
        } catch (Exception e) {
            System.out.println("Произошла ошибка: " + e.getMessage()); //

            Throwable[] suppressed = e.getSuppressed();
            for (Throwable t : suppressed) {
                System.out.println("Подавлено: " + t);
            }
        }
    }

    static class MyResource implements AutoCloseable {
        public void doSomething() throws Exception {
            System.out.println("Выполняем действия с ресурсом");
        }

        @Override
        public void close() throws Exception {
            System.out.println("Закрываем ресурс");
            throw new Exception("Ошибка при закрытии ресурса");
        }
    }
}
```

Вывод в консоль:

```
Выполняем действия с ресурсом
Закрываем ресурс
Произошла ошибка: Ошибка при закрытии ресурса
```

Пример когда `try` упал с ошибкой:

```java
class Example {

    public static void main(String[] args) {
        try (MyResource resource = new MyResource()) {
            resource.doSomething();
        } catch (Exception e) {
            System.out.println("Произошла ошибка: " + e.getMessage());
            Throwable[] suppressed = e.getSuppressed();
            for (Throwable t : suppressed) {
                System.out.println("Подавлено: " + t);
            }
        }
    }

    static class MyResource implements AutoCloseable {
        public void doSomething() throws Exception {
            System.out.println("Выполняем действия с ресурсом");
            throw new Exception("Ошибка внутри ресурса");
        }

        @Override
        public void close() throws Exception {
            System.out.println("Закрываем ресурс");
            throw new Exception("Ошибка при закрытии ресурса");
        }
    }
}
```

Вывод в консоль:

```
Выполняем действия с ресурсом
Закрываем ресурс
Произошла ошибка: Ошибка внутри ресурса
Подавлено: java.lang.Exception: Ошибка при закрытии ресурса
```

### 25. Что такое подавленные исключения?

Как мы уже обсудили выше, "подавленным" называется исключение которое произошло при закрытии ресурсов, когда мы
использовали конструкцию `try-with-resources`. Если блок `try` выбрасывает исключение и после этого мы получаем
исключение при закрытии ресурсов, то мы увидим исключение из блока `try`. Исключение, которое произошло при закрытии
ресурсов, будет "подавлено".

См последний пример выше.

### 26. Как достать подавленное исключение?

Для того чтобы достать "подавленное" исключение, мы должны использовать метода `getSuppressed()`. Этот метод возвращает
массив исключений, которые были подавленны. Мы получаем массив, поскольку в конструкции `try-with-resources` мы можем
начать работу сразу с несколькими ресурсами.