# Вопросы для интервью Java

## Базовый синтаксис:

1. Какие есть примитивные типы и какие у них размеры?
2. Почему 0.1 + 0.7 != 0.8? (float 0.9+0.7 считает с погрешностью, double почти все)
3. Что такое char? Почему над ним можно выполнять арифметические операции?
4. Какие есть виды приведения типов?
5. В каком случае компилятор не может сделать приведение сам и просит сделать приведение программиста?
6. Какие есть классы-обертки?
7. Зачем нужны классы-обертки? Immutable ли обертки?
8. Что такое unboxing(распаковка), autoboxing(автоупаковка) в обертках.
9. Если при распаковке обертка была равна `null`, произойдет исключение `java.lang.NullPointerException`?
10. Может ли примитив быть `null`? Что такое литерал?
11. Что такое `String Pool` (пул строк) и `Primitive Pool` (пул примитивов)?
12. Integer a = 100; Integer b = 100; System.out.println(b == a); Какой результат будет?
13. Почему не рекомендуются множественные конкатенации `String`?
14. Разница между `String`, `StringBuilder` (Java 1.5) и `StringBuffer`(Java 1.0)?
15. Что такое массив, какие на нём есть ограничения?
16. Существуют ли многомерные массивы в java? Как создать многомерный массив?
17. Что такое метод и чем отличается от функции, возвращаемое значение, аргументы метода?
18. Что такое инкремент и декремент?
19. Чем отличаются постфиксная и префиксная форма?
20. Какие есть логические операции?
21. А если подряд три true XOR true XOR true какой результат?
22. Расскажи про все условные операторы?
23. Можно ли в switch case использовать String, Enum?
24. Какие есть циклы в Java? Чем отличаются друг от друга? (пост условие пред условие)
25. Что такое continue и break? Почему не рекомендуется их использовать?
26. Если в case не поставить break что будет?
27. Что такое рекурсия? Недостатки и преимущества?
28. Зачем нужны BigInteger и BigDecimal?

## ООП

1. Что такое ООП? В чем его плюсы?
2. Перечислите основные принципы ООП (3 штуки) без объяснений?
3. Что такое инкапсуляция? Приведите пример инкапсуляции?
4. Что такое полиморфизм? Приведите пример полиморфизма?
5. Что такое наследование? Приведите пример наследования? Зачем оно нужно?
6. Что такое класс? Объект?
7. Передача параметров по ссылке или по значению?
8. Как передаются объекты в метод?
9. Что будет если передать массив в метод, который изменит его значения, изменятся ли они вне метода? Почему? А если
   передать примитив?
10. Что такое переопределение метода в Java?
11. Что такое перегрузка метода в Java?
12. Что такое нативные методы, их плюсы и минусы?
13. Перечислите все модификаторы доступа в порядке уменьшения закрытости, какую область видимости они имеют?
14. Что такое final?
15. Что может быть final? Как они работают?
16. Как реализована неизменность String?
17. Как реализовать свой Immutable тип данных?
18. Что такое ключевое слово static? Что может быть static? Можно ли использовать статические методы в обычных?
    Наоборот? Почему?
19. Может ли статический метод быть перегружен?
20. Будет ли работать переопределение статического метода?
21. Могут ли нестатические методы перегрузить статические?
22. Что такое пакет? Как создать пакет?
23. Что такое конструкторы? Конструктор по-умолчанию?
24. Будет ли в классе конструктор и какой, если при его создании ни один не был задан?
25. Будет ли создан автоматически конструктор по-умолчанию, если в созданном классе есть любой другой конструктор?
26. Можно ли в классе вызвать один конструктор из другого? Как это сделать?
27. Как вызвать конструктор родителя?
28. Расскажи, что такое this и super? Когда мы обязаны использовать this и super?
29. Класс Object, все методы кроме wait, notify, notifyAll, назвать и объяснить, как работают
30. Зачем нужен метод finalize?
31. Назовите контракт между equals и hashcode? Из-за чего происходят коллизии?
32. Почему нельзя написать hashcode гарантировано без коллизий?
33. В чём разница между instanceOf и getClass?
34. Перечислите методы именно класса Enum?
35. Что такое интерфейс? Когда использовать интерфейс? Можно ли создать поля в интерфейсе?
36. Есть ли в Java множественное наследование классов?
37. Что дает множественная реализация интерфейсов?
38. Зачем наследовать интерфейс интерфейсу?
39. Можно ли создавать статик методы в интерфейсах?
40. Что такое абстрактный метод?
41. Что такое абстрактный класс? Чем отличается от обычного?
42. Может ли быть абстрактный класс без абстрактных методов?
43. Может ли быть конструктор у абстрактного класса? Для чего?
44. Синтаксические отличия интерфейса от абстрактного класса (АК)? 5 отличий

## Коллекции

1. Что такое коллекции (`Collection`) в Java? Какие основные интерфейсы коллекций вы знаете? Нарисуйте иерархию классов
   коллекций.
2. В чем разница между `List`, `Set` и `Map`?
3. Что такое `ArrayList`? В чем разница между `ArrayList` и `LinkedList`?
4. Что такое `HashMap`? Какие основные методы доступа и модификации данных в `HashMap`?
5. Что такое `HashSet`? Какая особенность у HashSet в отношении дубликатов и порядка элементов?
6. Что такое итератор (`Iterator`)? Как его использовать для перебора элементов коллекции?
7. Какие коллекции из Java Collections Framework потокобезопасны (thread-safe) по умолчанию?
8. Что такое ConcurrentHashMap? В чем его отличие от HashMap?
9. Что такое синхронизированные (synchronized) коллекции? Какие есть синхронизированные реализации в Java?
10. Как можно сортировать элементы в коллекциях? Какой интерфейс следует использовать для сортировки?

## Исключения

1. Что такое исключение (`Exception`) в Java? Какие проблемы они помогают обрабатывать?
2. Нарисуйте иерархию исключений.
3. Чем отличается checked исключение от unchecked исключения?
4. Назовите знакомые вам исключения и когда они могут возникнуть.
5. Что такое try-with-resources? Как его использовать для автоматического закрытия ресурсов?
6. Что произойдет с исключением, выкинутым из блока finally?

## Threads

1. Что такое поток (`Thread`) в Java?
2. В чем отличие потока (`Thread`) от процесса (`Process`)?
3. Как создать новый поток?
4. Что значит и для чего используется ключевое слово `final`?
5. Что значит и для чего используется ключевое слово `volatile`? Как оно влияет на работу с переменными в многопоточной
   среде?
6. Что значит и для чего используется ключевое слово `synchronized`?
7. Что такое монитор?
8. Какие методы класса Object используются для синхронизации и ожидания потоков?
9. Что такое wait() и notify() методы? Как они используются для синхронизации потоков?
10. Что такое взаимная блокировка (deadlock)? Как она возникает и как ее избежать?
11. Что вы знаете о пакете `java.util.concurrent`?

## Ответы

### 1. Какие есть примитивные типы и какие у них размеры?

| Тип данных | Размер в байтах | Размер в битах | Диапазон значений                                          |
|------------|-----------------|----------------|------------------------------------------------------------|
| byte       | 1               | 8              | -128 до 127                                                |
| short      | 2               | 16             | -32,768 до 32,767                                          |
| int        | 4               | 32             | -2,147,483,648 до 2,147,483,647                            |
| long       | 8               | 64             | -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807    |
| float      | 4               | 32             | Приблизительно ±3.40282347E+38 (6-7 значащих цифр)         |
| double     | 8               | 64             | Приблизительно ±1.7976931348623157E+308 (15 значащих цифр) |
| char       | 2               | 16             | 0 до 65,535 (включая полный набор Unicode символов)        |
| boolean    | 1               | 8              | true или false                                             |

### 2. Почему 0.1 + 0.7 != 0.8? (float 0.9+0.7 считает с погрешностью, double почти все)

Для хранения чисел с дробной частью в компьютерах
используется [Двоичная система с плавающей запятой](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D1%81_%D0%BF%D0%BB%D0%B0%D0%B2%D0%B0%D1%8E%D1%89%D0%B5%D0%B9_%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%BE%D0%B9).
В Java для этого используются типы данных `float` и `double`, однако, из-за ограниченного количества бит для
представления чисел, некоторые дробные значения не могут быть точно представлены, что может приводить к неточным
результатам при арифметических операциях. Чтобы избежать проблем с точностью, рекомендуется
использовать класс `BigDecimal` или сравнивать числа с маленькой допустимой погрешностью вместо проверки на точное
равенство.

### 3. Что такое char? Почему над ним можно выполнять арифметические операции?

`char` - это примитивный числовой тип данных, который используется для представления одного
символа [Unicode](https://en.wikipedia.org/wiki/Unicode). По сути, каждый символ `Unicode` представляется числовым
значением, поэтому выполнять арифметические операции с `char` возможно.
Пример:

```java
class Example {
    public static void main(String[] args) {
        char ch1 = 'a'; // числовое значение 97
        char ch2 = 'b'; // числовое значение 98
        char result = (char) (ch1 + ch2); // числовое значение 97 + 98 = 195
    }
}
```

### 4. Какие есть виды приведения типов?

- Неявное (автоматическое) приведение типов. Происходит автоматически, когда значение одного типа данных присваивается
  переменной другого типа с большим диапазоном значений. Например, присваивание int (4 байта) переменной типа double (8
  байт).

```java
class Example {
    public static void main(String[] args) {
        // Пример 1
        int x = 10;
        double y = x; // Неявное приведение int к double

        // Пример 2 
        float a = 3.14f;
        double b = a; // Неявное приведение float к double
    }
}
```

- Явное (ручное) приведение типов: Происходит вручную, когда мы явно указываем, что хотим преобразовать
  из одного типа в другой. При явном приведение типов может происходить потеря данных.

```java
class Example {
    public static void main(String[] args) {
        // Пример 1
        double c = 7.65;
        int d = (int) c; // Явное приведение double к int, дробная часть будет отброшена


        // Пример 2
        int e = 130;
        byte f = (byte) e; // Явное приведение int к byte, возможна потеря данных из-за переполнения
    }
}
```

### 5. В каком случае компилятор не может сделать приведение сам и просит сделать приведение программиста?

Компилятор может выполнять неявное (автоматическое) приведение типов, когда оно безопасно и не приводит к потере данных.

- Преобразование из типа с большим диапазоном к типу с меньшим диапазоном. Например, преобразование `double` к `int`,
  что
  может привести к потере дробной части.
- Преобразование между различными типами данных, например, преобразование `float` к `int`.
- Передача аргументов методам с различными типами. Если типы аргументов метода не совпадают с типами параметров,
  требуется явное приведение.

### 6. Какие есть классы-обертки?

Для каждого примитивного типа данных в Java есть обертка, которая позволяют превратить его в объект

| Примитивный тип данных | Обертка   |
|------------------------|-----------|
| byte                   | Byte      |             
| short                  | Short     |             
| int                    | Integer   |             
| long                   | Long      |             
| float                  | Float     |             
| double                 | Double    |    
| char                   | Character |    
| boolean                | Boolean   |

### 7. Зачем нужны классы-обертки? Immutable ли обертки?

Обертки позволяют нам работать с примитивными типами данных как с объектами. Это особенно полезно, когда мы
работаем с классами из пакета `java.util.Collections`, которые могут хранить только объекты, а не примитивные типы.

Обертки являются неизменяемыми (immutable), так что каждый раз создается новый объект.

### 8. Что такое unboxing(распаковка), autoboxing(автоупаковка) в обертках.

Unboxing(распаковка) и autoboxing(автоупаковка) - это процессы автоматического преобразования между примитивными типами
и соответствующими обертками, благодаря которым мы можем бесшовно использоваться обертки и примитивы.

- Autoboxing (автоупаковка) - процесс автоматического преобразования из примитива в обертку.
- Unboxing (распаковка) - процесс автоматического преобразования обертки обратно в примитивный тип.

```java
class Example {
    public static void main(String[] args) {
        int a = 42;

        Integer wrappedA = a; // Автоупаковка, int преобразуется в Integer

        int b = wrappedA; // Распаковка, Integer преобразуется в int
    }
}
```

### 9. Если при распаковке обертка была равна `null`, произойдет исключение `java.lang.NullPointerException`?

Да, мы получим `NPE`, поскольку мы получим `null` при распаковке, а примитивные типы данных не могут быть равны `null`.

### 10. Может ли примитив быть `null`? Что такое литерал?

Примитивные типы данных не могут быть равны `null`.
Литералы - это **константные** значения, которые находятся в коде и не меняются во время работы программы.

### 11. Что такое `String Pool` (пул строк) и `Primitive Pool` (пул примитивов)?

Пул строк и пул примитивов - это механизм в Java используемый для оптимизации использования памяти и повышения
производительности, за счет использования уже существующих значений, вместо создания новых.

Пример для `String Pool`:

```java
class Example {
    public static void main(String[] args) {
        String str1 = "Hello"; // Строка добавляется в String Pool
        String str2 = "Hello"; // Используется уже существующая ссылка из String Pool
        String str3 = new String("Hello"); // Не добавляется в String Pool, создается новый объект

        System.out.println(str1 == str2); // true, так как используется ссылка из String Pool
        System.out.println(str1 == str3); // false, так как мы создали новый объект str3
    }
}
```

`Primitive Pool`:
Стоит отметить, что в Primitive Pool сохраняются не все примитивные типы.
`long`,`float`, `double` не сохраняются в Primitive Pool.

| Примитивный тип данных | Диапазон который сохраняется в Pool                        |
|------------------------|------------------------------------------------------------|
| byte                   | -128 до 127                                                |             
| short                  | -128 до 127                                                |             
| int                    | -128 до 127                                                |              
| char                   | '\u0000' (нулевой символ) до '\u007F' (символ с кодом 127) |    
| boolean                | true и false                                               |

### 12. Integer a = 100; Integer b = 100; System.out.println(b == a); Какой результат будет?

Результат будет `true`, поскольку 100 входит в диапазон значений для Primitive Pool.

```java
class Example {
    public static void main(String[] args) {
        Integer a = 100;
        Integer b = 100;
        System.out.println(a == b); // true

        Integer c = 1000;
        Integer d = 1000;
        System.out.println(c == d); // false
    }
}
```

### 13. Почему не рекомендуются множественные конкатенации `String`?

В Java String являются неизменяемыми объектами, что означает, что каждая операция сложения будет создавать новую строку.
Вместо простого сложения большого количества строк лучше иcпользовать `StringBuilder`.

```java
class Example {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        sb.append("Hello");
        sb.append(" ");
        sb.append("World");
        String result = sb.toString();
        System.out.println(result);
    }
}
```

### 14. Разница между `String`, `StringBuilder` (Java 1.5) и `StringBuffer`(Java 1.0)?

`String` - это неизменяемый класс, из-за чего при его изменении (конкатенация, создание подстроки итд) каждый раз
создается новая строка.

`StringBuilder` - это изменяемый класс, который позволяет изменять строку без создания новых строк. Так же предоставляет
методы для изменения, добавления и удаления символов или подстрок в строке, что делает его более эффективным при
множественных изменениях строки.

`StringBuffer` - это потоко-безопасный (thread-safe) аналог `StringBuilder`.

### 15. Что такое массив, какие на нём есть ограничения?

Массив - это структура данных, которая представляет собой упорядоченную коллекцию элементов одного типа. Элементы
массива расположены в памяти последовательно.

Ограничения массивов:

1. Фиксированный размер. Размер массива определяется в момент его создания и не может изменяться в дальнейшем
2. Один тип данных. Массив может содержать элементы только одного типа данных.
3. Индексация. Элементы массива нумеруются с нуля. Доступ к элементам осуществляется по их индексу, и выход за пределы
   массива может привести к ошибке `ArrayIndexOutOfBoundsException`.

### 16. Существуют ли многомерные массивы в java? Как создать многомерный массив?

Да, существуют. Многомерный массив - это собой массив массивов или, другими словами, это
массив, элементами которого также являются массивы. Наиболее распространенные многомерные массивы - это двумерные
массивы, но можно создавать массивы с большим числом измерений.

Пример создания многомерного массива:

```java
class Example {
    public static void main(String[] args) {
        // двумерный массив размером 3x4 (3 строки и 4 столбца).
        int[][] twoDimensionalArray = new int[3][4];

        // трехмерный массив размером 2x3x4 (2 блока, каждый из которых содержит 3 строки и 4 столбца).
        int[][][] threeDimensionalArray = new int[2][3][4];
    }
}
```

### 17. Что такое метод и чем отличается от функции, возвращаемое значение, аргументы метода?

Метод - это блок кода внутри класса, выполняющий определенную операцию или действие. Привязан к объектам класса.

Термин "функция" часто используется как синоним "метода", однако "функция" не привязана к объекту класса.

Возвращаемое значение - это значение, которое метод возвращает после выполнения операции.

Аргументы метода - это значения, переданные в метод при его вызове для использования внутри метода.

### 18. Что такое инкремент и декремент?

Инкремент и декремент - это унарные операции, которые увеличивают (инкремент) или уменьшают (декремент) значение
переменной на единицу.

```java
class Example {
    public static void main(String[] args) {

        // Инкремент
        int x = 5;
        x++; // Теперь x равно 6

        // Декремент
        int y = 10;
        y--; // Теперь y равно 9

    }
}
```

### 19. Чем отличаются постфиксная и префиксная форма?

Постфиксная и префиксная формы отличаются порядком выполнения операций, что произойдет раньше изменение значения или его
возврат.

- Постфиксная форма
    - Возврат значения переменной
    - Изменение значения переменной
- префиксная форма
    - Изменение значения переменной
    - Возврат значения переменной

```java
class Example {
    public static void main(String[] args) {

        // Постфиксная форма
        int x = 5;
        // Сначала мы присвоим значение x равное 5 в переменную resultX, а уже после мы увеличим его на 1
        // Результат: x=6 resultX=5
        int resultX = x++;


        // Префиксная форма
        int y = 10;
        // Сначала мы увеличим значение на 1 и получим y=11, а уже после мы присвоим значение y равное 11 в переменную resultY
        // Результат: y=11 resultY=11
        int resultY = ++y;
    }
}
```

### 20. Какие есть логические операции?

1. Логическое И (AND) записывается как (&&). Принимает значение `true` только если оба параметра являются
   истинными `true`. Таблица истинности:

| A     | B     | A && B |
|-------|-------|--------|
| true  | true  | true   |
| true  | false | false  |
| false | true  | false  |
| false | false | false  |

2. Логическое ИЛИ (OR) записывается как (||). Принимает значение `true` сли хотя бы один из параметров является
   истинным `true`. Таблица истинности:

| A     | B     | A \|\| B |
|-------|-------|----------|
| true  | true  | true     |
| true  | false | true     |
| false | true  | true     |
| false | false | false    |

3. Логическое НЕ (NOT) записывается как (!). Изменяет значение параметра на противоположное
   Таблица истинности:

| A     | !A    |
|-------|-------|
| true  | false |
| false | true  |

4. Исключающее ИЛИ (XOR) записывается как (^). Принимает значение `true` только если один параметр является
   истинным `true`. Таблица истинности:

| A     | B     | A ^ B |
|-------|-------|-------|
| true  | true  | false |
| true  | false | true  |
| false | true  | true  |
| false | false | false |

Вы можете скопировать и вставить этот код в свой файл формата Markdown для отображения таблицы истинности логических
операций.

### 21. А если подряд три true XOR true XOR true какой результат?

Результат будет true, поскольку `true XOR true = false`, а `false XOR true = true`.

```java
class Example {
    public static void main(String[] args) {
        boolean result = true ^ true ^ true;

        System.out.println("Результат выражения: " + result);
    }
}
```

### 22. Расскажи про все условные операторы?

В Java существуют три условных оператора `if`, `switch` и Тернарный оператор `?`.

1. Оператор `if` выполняет код если условие истинное, если же оно ложное, то выполняется код в блоке `else`, однако его
   может и не быть.
   Пример:

```java
class Example {
    public static void main(String[] args) {
        int x = 10;

        // If без else
        if (x > 0) {
            System.out.println("Число положительное");
        }

        // if-else
        if (x > 0) {
            System.out.println("Число положительное");
        } else {
            System.out.println("Число не положительное");
        }

        // несколько if-else
        if (x > 0) {
            System.out.println("Число положительное");
        } else if (x < 0) {
            System.out.println("Число отрицательное");
        } else {
            System.out.println("Число равно нулю");
        }
    }
}
```

2. Оператор `switch` может иметь несколько блоков кода, каждый из которых выполниться при определенном условии.

```java
class Example {
    public static void main(String[] args) {
        int dayOfWeek = 3;
        switch (dayOfWeek) {
            case 1:
                System.out.println("Понедельник");
                break;
            case 2:
                System.out.println("Вторник");
                break;
            case 3:
                System.out.println("Среда");
                break;
            default:
                System.out.println("День недели неизвестен");
        }

    }
}
```

3. Тернарный оператор `?` является упрощенной формой записи оператора `if-else`.
   Форма записи тернарного оператора: `условие ? значение_если_истина : значение_если_ложь`

```java
class Example {
    public static void main(String[] args) {
        int a = 10;
        int b = 5;
        int max = (a > b) ? a : b;
        System.out.println("Максимальное значение: " + max);
    }
}
```

### 23. Можно ли в switch case использовать String, Enum?

Да, в switch case можно использовать строки и перечисления.

Пример со строкой:

```java
class Example {
    public static void main(String[] args) {
        String dayOfWeek = "Monday";
        switch (dayOfWeek) {
            case "Monday":
                System.out.println("Понедельник");
                break;
            case "Tuesday":
                System.out.println("Вторник");
                break;
            // ... другие варианты дней недели ...
            default:
                System.out.println("День недели неизвестен");
        }

    }
}
```

Пример с перечислением:

```java
class Example {
    public static void main(String[] args) {
        enum Color {
            RED, GREEN, BLUE;
        }

        Color color = Color.RED;
        switch (color) {
            case RED:
                System.out.println("Красный");
                break;
            case GREEN:
                System.out.println("Зеленый");
                break;
            case BLUE:
                System.out.println("Синий");
                break;
            default:
                System.out.println("Цвет неизвестен");
        }
    }
}
```

### 24. Какие есть циклы в Java? Чем отличаются друг от друга? (пост условие пред условие)

1. Цикл `for` используется для выполнения блока кода заданное количество раз.
   Синтаксис:

```java
for(инициализация;условие;операци после итерации){
        // Блок кода, который будет выполняться
        }
```

2. Цикл `while`, используется для выполнения блока кода, пока заданное условие истинно.
   Синтаксис:

```java
while(условие){
        // Блок кода, который будет выполняться
        }
```

3. Цикл `do-while` похож на цикл "while", но проверка условия происходит после каждой итерации, поэтому блок кода
   выполняется хотя бы один раз, даже если условие изначально ложно.
   Синтаксис:

```java
do{
        // Блок кода, который будет выполняться
        }while(условие);
```

### 25. Что такое continue и break? Почему не рекомендуется их использовать?

`continue` и `break` - это управляющие операторы.
Рекомендация: в некоторых случаях `continue` и `break` могут использоваться, однако нужно стараться избегать частого
их использования, поскольку они усложняют логику и затрудняют понимание кода.

1. `Continue` - используется в циклов (`for`, `while`, `do-while`), чтобы перейти к следующей итерации.

```java
class Example {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            if (i == 3) {
                continue; // Пропустить i = 3 и перейти к следующей итерации
            }
            System.out.println(i);
        }
        // Результат в консоли: 1, 2, 4, 5
    }
}
```

2. `Break` - используется в циклах и в `switch` для того, чтобы преждевременно выйти из него.

```java
class Example {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            if (i == 3) {
                break; // Завершить цикл, если i = 3
            }
            System.out.println(i);
        }
        // Результат в консоли: 1, 2
    }
}
```

### 26. Если в case не поставить break что будет?

Если не добавить `break` в конце `case`, то произойдет так называемое "проваливание (fall-through)" и начнет выполняться
следующий блок `case`.

```java
class Example {
    public static void main(String[] args) {
        int dayOfWeek = 3;
        switch (dayOfWeek) {
            case 1:
                System.out.println("Понедельник");
            case 2:
                System.out.println("Вторник");
            case 3:
                System.out.println("Среда");
            case 4:
                System.out.println("Четверг");
            case 5:
                System.out.println("Пятница");
            default:
                System.out.println("Выходные");

                // Результат в консоли:
                // Среда
                // Четверг
                // Пятница
                // Выходные
        }
    }
}
```

### 27. Что такое рекурсия? Недостатки и преимущества?

Рекурсия - это техника в программировании, при которой функция вызывает саму себя. Это позволяет решать сложные задачи
шаг за шагом.
Хорошим примером рекурсии является решение задачи по вычислению факториала числа.

```java
class Example {
    public static void main(String[] args) {
        System.out.println(factorial(10)); // Результат: 3628800
    }

    static int factorial(int n) {
        if (n == 0 || n == 1) {
            return 1;
        } else {
            return n * factorial(n - 1);
        }
    }

}
```

Преимущества:

1. Позволяет решать сложные задачи постепенно через разбиение на простые подзадачи.
2. Удобство решения. Решение некоторых задач очень удобно можно представить в рекурсивной форме, к примеру обход
   деревьев или графов.
3. В некоторых ситуациях, рекурсия может быть более эффективной чем итеративные подходы.

Недостатки

1. Потенциальная переполнение стека. Каждый рекурсивный вызов добавляется в стек, так как что если рекурсия слишком
   глубокая, то может произойти переполнение стека с ошибкой `StackOverflowError`.
2. Рекурсия может проигрывать итеративным подходам за счет дополнительных расходов на управление стеком вызовов.
3. Рекурсивные функции сложны для отладки, из-за того, что мы постоянно делаем вложенные вызовы.

### 28. Зачем нужны BigInteger и BigDecimal?

`BigInteger` и `BigDecimal` нужны для того, чтобы работать с числами, которые не помещаются в примитивные типы данных.
`BigInteger` позволяет работать с целыми числами произвольной длины числами
`BigDecimal`позволяет работать с плавающей запятой произвольной точности.

## OOП

### 1. Что такое ООП? В чем его плюсы?

ООП (Объектно-Ориентированное Программирование) - это подход в программировании при котором программа представляется в
виде набора объектов. Объекты состоят из данных (поля объекта) и операции (методы в объекта) для работы с этими данными.
В ООП основное внимание уделяется объектам и их взаимодействию, а не просто последовательности функций, как
в процедурном программировании.

#### Плюсы

- Модульность и структурирование. ООП позволяет разбивать программы на небольшие, независимые классы, что упрощает
  разработку, понимание и тестирование кода.
- Повторное использование кода. Благодаря наследованию и полиморфизму мы можем повторно использовать код, что
  способствует уменьшению дублирования и обеспечивает экономию времени при разработке.
- Гибкость и расширяемость. ООП позволяет легко добавлять новые функции или изменять существующую логику без
  необходимости переписывания всего кода.
- Улучшенное управление сложность. ООП позволяет управлять сложностью программы, разделяя ее на меньшие, легко
  управляемые части.

### 2. Перечислите основные принципы ООП (3 принципа без объяснений)?

1. Инкапсуляция - сокрытие реализации.
2. Наследование - создание новой сущности на базе уже существующей.
3. Полиморфизм - возможность иметь разные формы для одной и той же сущности.

### 3. Что такое инкапсуляция?

Инкапсуляция - это принцип ООП, который говорит о том, что нужно скрывать внутренние свойства объекта такие, как данные
или методы от внешнего доступа и предоставлять доступ только к тому, что необходимо при последующем использовании.

```java
public class BankAccount {
    private String accountNumber;
    private double balance;

    public BankAccount(String accountNumber, double initialBalance) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }

    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        }
    }

    public void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
        }
    }

    public double getBalance() {
        return balance;
    }
}
```

В этом примере класс `BankAccount` инкапсулирует свои поля `accountNumber` и `balance`, чтобы предотвратить прямой
доступ извне. За изменение баланса отвечают методы `deposit` и `withdraw`, которые проверяют, что сумма для депозита или
снятия положительная и не превышает текущий баланс. Доступ к балансу осуществляется через метод `getBalance`, который
возвращает текущий баланс без возможности изменения его значения напрямую извне.

### 4. Что такое полиморфизм?

Полиморфизм - это принцип ООП, который позволяет объектам разных классов обладать одинаковым интерфейсом и проявлять
разное поведение в зависимости от своего конкретного типа. В контексте полиморфизма, один интерфейс может иметь
несколько различных реализаций.

Давайте рассмотрим более реалистичный пример полиморфизма на примере классов `Shape` и его наследников `Circle`
и `Rectangle`. У каждой фигуры есть метод `calculateArea()`, который будет проявлять разное поведение в зависимости от
типа фигуры.

```java
interface Shape {
    String shapeName();

    double calculateArea();
}

class Circle extends Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public String shapeName() {
        return "Circle";
    }

    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape {
    private double width;
    private double height;

    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public String shapeName() {
        return "Rectangle";
    }

    @Override
    public double calculateArea() {
        return width * height;
    }
}
```

Теперь создадим массив объектов типа `Shape`, и добавим в него экземпляры классов `Circle` и `Rectangle`. В результате,
когда вызываем метод `calculateArea()` для каждого элемента массива, он будет проявлять разное поведение в зависимости
от типа фигуры.

```java
public class Example {
    public static void main(String[] args) {
        Shape[] shapes = new Shape[2];
        shapes[0] = new Circle(5.0);
        shapes[1] = new Rectangle(4.0, 6.0);

        for (Shape shape : shapes) {
            System.out.println(shape.shapeName() + " area = " + shape.calculateArea());
        }
    }
}
```

Результат:
Circle area: 78.53981633974483
Rectangle area: 24.0

Здесь полиморфизм проявляется в том, что объекты классов `Circle` и `Rectangle` определенны как интерфейс `Shape`, и
метод `calculateArea()` вызывает разные реализации в зависимости от типа фигуры. Это позволяет общему интерфейсу `Shape`
проявлять разное поведение для различных подтипов, что является примером полиморфизма в ООП.

### 5. Что такое наследование?

Наследование - это принцип ООП, который позволяет создавать новый класс (подкласс или класс-наследник) на основе уже
существующего класса (суперкласс или базовый класс). Подкласс наследует свойства и методы суперкласса и может добавлять
свои собственные свойства и методы.

Основные принципы наследования:

- Переиспользование кода. Наследование позволяет повторно использовать код, который уже был написан в суперклассе, без
  необходимости повторно его реализовывать в каждом подклассе.
- Расширяемость и гибкость. Подклассы могут добавлять новые свойства и методы, что позволяет расширять функциональность
  существующих классов и создавать новые классы на основе уже существующих.
- Иерархия классов. Наследование позволяет создавать иерархию классов, где подклассы могут наследовать свойства и методы
  от своих суперклассов, образуя древовидную структуру классов.

В этом примере классы `Dog` и `Cat` являются подклассами класса `Animal`, таким образом, они наследуют его свойства и
методы, в данном случае, свойство `name` и метод `eat()`. Подклассы также могут добавлять свои собственные методы, такие
как `bark()`в классе `Dog` и `meow()` в классе `Cat`. Это позволяет создавать специализированные классы на основе общего
функционала

```java
class Animal {
    String name;

    public void eat() {
        System.out.println(name + " is eating.");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println(name + " is barking.");
    }
}

class Cat extends Animal {
    public void meow() {
        System.out.println(name + " is meowing.");
    }
}
```

### 6. Что такое класс? Объект?

Класс это шаблон, который описывает состояние (поля) и поведение (методы). Его можно рассматривать как абстракцию,
которая представляет некоторый тип объектов и определяет их общие свойства и действия.

Пример класса `Person`, который описывает человека и имеет два поля (`name` и `age`) и метод `sayHello()` для
приветствия.

```java
public class Person {
    private final String name;
    private final int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void sayHello() {
        System.out.println("Hello, my name is " + name + " and I am " + age + " years old.");
    }
}
```

Объект - это экземпляр класса, который имеет уникальные значения своих полей и может выполнять определенные действия,
определенные методами класса.

В приведенном ниже примере мы создаем два объекта, каждый из которых будет иметь свои уникальные значения полей.

```java
public class Example {
    public static void main(String[] args) {
        // Создание объекты класса Person
        Person person1 = new Person("John", 30);
        Person person2 = new Person("Kate", 25);

        // Вызов метода sayHello() для объекта person1 и person2
        person1.sayHello();
        person2.sayHello();
    }
}
```

### 7. Передача параметров по ссылке или по значению?

В Java значения могут передаваться как по ссылке, так и по значению. Для понимания разницы между передачей по значению и
по ссылке, важно различать примитивные типы данных (int, double, boolean, и т.д.) и ссылочные типы данных (классы и
объекты).

- Передача параметров примитивных типов данных происходит **по значению**.

```java
public class Example {
    public static void main(String[] args) {
        int x = 10;
        modifyValue(x);
        System.out.println(x); // Выведет: 10 (значение переменной x не изменится)
    }

    public static void modifyValue(int value) {
        value = 20; // Изменяем копию значения, но не влияем на исходную переменную
    }
}
```

- Передача параметров ссылочных типов данных происходит **по ссылке**:

```java
public class Example {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder("Hello");
        modifyStringBuilder(sb);
        System.out.println(sb); // Выведет: Hello World (значение объекта изменится)
    }

    public static void modifyStringBuilder(StringBuilder builder) {
        builder.append(" World"); // Модифицируем объект, на который ссылается builder
    }
}
```

### 9. Что будет если передать массив в метод, который изменит его значения, изменятся ли они вне метода? Почему? А если передать примитив?

Массивы являются ссылочными типами данных, следовательно, если передать массив в метод и внутри метода изменить что-то в
нем, то мы увидим эти изменения вне метода тоже.

```java
public class Example {
    public static void main(String[] args) {
        int[] array = {1, 2, 3};
        modifyArray(array);
        System.out.println(Arrays.toString(array)); // Выведет: [10, 20, 30]
    }

    public static void modifyArray(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            arr[i] *= 10;
        }
    }
}
```

### 10. Что такое переопределение метода в Java?

Переопределение метода (Method Overriding) - это механизм ООП, когда подкласс (наследник) предоставляет свою
собственную реализацию метода, который уже определен в его суперклассе (базовом классе). При переопределении метода,
сигнатура (имя, параметры) метода в подклассе должна точно совпадать с сигнатурой метода в суперклассе.

Когда объект подкласса вызывает переопределенный метод, будет использоваться реализация метода из подкласса, а не из
суперкласса. Это позволяет объектам различных типов проявлять разное поведение для одноименных методов, что является
примером полиморфизма в ООП.

Условия для переопределения метода:

1. Название метода, параметры и возвращаемый тип в подклассе должны точно совпадать с сигнатурой метода в суперклассе.
2. Модификатор доступа метода в подклассе не может быть менее доступным, чем в суперклассе (например, если метод в
   суперклассе имеет модификатор `protected`, то в подклассе он также должен иметь `protected` или более доступный
   модификатор, такой как `public`).
3. Возвращаемый тип метода в подклассе может быть подтипом возвращаемого типа в суперклассе (ковариантное возвращаемое
   значение).

Пример:
Класс `Dog` наследует от класса `Animal` и переопределяет его метод `makeSound()`. Когда объект
типа `Dog` вызывает метод `makeSound()`, будет использоваться переопределенная реализация из класса `Dog`, что позволяет
собаке произносить звук "Woof woof!" вместо общего звука, определенного в суперклассе `Animal`.

```java
class Animal {
    public void makeSound() {
        System.out.println("Some generic animal sound");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Woof woof!");
    }
}
```

### 11. Что такое перегрузка метода в Java?

Перегрузка метода - это механизм ООП, который позволяет создать в одном классе несколько методов с одним и тем же
именем, методы будут отличаться только количеством или типом параметров. Когда вызывается перегруженный метод, Java
определяет, какой из перегруженных методов будет вызываться, основываясь на переданных аргументах вызова метода.

Пример:

```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }

    public int add(int a, int b, int c) {
        return a + b + c;
    }
}
```

Вызов:

```java
public class Example {
    public static void main(String[] args) {
        Calculator calculator = new Calculator();
        int result1 = calculator.add(3, 5); // Вызов первого метода add(int, int)
        double result2 = calculator.add(2.5, 4.7); // Вызов второго метода add(double, double)
        int result3 = calculator.add(1, 2, 3); // Вызов третьего метода add(int, int, int)
    }
}
```

### 12. Что такое нативные методы, их плюсы и минусы?

Нативные методы - это методы, которые реализованы на другом языке (к примеру C, C++ итд). В большинстве случаев, эти
методы используются для выполнения задач, которые могут быть реализованы более эффективно. Например, для работы с
низкоуровневыми операциями системы, библиотеками операционной системы или оборудования.

- Плюсы
    - Могут улучшить производительность.
    - Можно получить доступ к низкоуровневым функциями, которых нет в Java.
- Минусы
    - Нужно поддерживать код на другом языке.
    - Могут возникнуть проблемы с переносимостью кода на различне платформы.
    - Могут быть не безопасными, так как нарушают изоляцию Java.

### 13. Перечислите все модификаторы доступа в порядке уменьшения закрытости, какую область видимости они имеют?

| Модификатор доступа | Область видимости                        |
|---------------------|------------------------------------------|
| private             | Доступен только в пределах класса        |
| (default)           | Доступен в пределах пакета               |
| protected           | Доступен в пределах пакета и наследникам |
| public              | Доступен отовсюду                        |

### 14. Что такое final?

`final` - это ключевое слово, которое используется для обозначения неизменяемых сущностей - констант, переменных,
методов и классов.
Значение или поведение сущностей, помеченных как final, не может быть изменено или переопределено после инициализации.

### 15. Что может быть final? Как они работают?

1. `Переменная`. Когда переменная помечена как `final`, ее значение не может быть изменено после
   первоначальной инициализации.
2. `Метод`. Когда метод объявлен как `final`, он не может быть переопределен(Override).
3. `Класс`. Когда класс объявлен как `final`, он не может быть наследован, т.e. нельзя создать подклассы этого класса.
