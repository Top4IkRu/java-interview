# Вопросы для интервью Java

## Базовый синтаксис:

1. Какие есть примитивные типы и какие у них размеры?
2. Почему 0.1 + 0.7 != 0.8? (float 0.9+0.7 считает с погрешностью, double почти все)
3. Что такое char? Почему над ним можно выполнять арифметические операции?
4. Какие есть виды приведения типов?
5. В каком случае компилятор не может сделать приведение сам и просит сделать приведение программиста?
6. Какие есть классы-обертки?
7. Зачем нужны классы-обертки? Immutable ли обертки?
8. Что такое unboxing(распаковка), autoboxing(автоупаковка) в обертках.
9. Если при распаковке обертка была равна `null`, произойдет исключение `java.lang.NullPointerException`?
10. Может ли примитив быть `null`? Что такое литерал?
11. Что такое `String Pool` (пул строк) и `Primitive Pool` (пул примитивов)?
12. Integer a = 100; Integer b = 100; System.out.println(b == a); Какой результат будет?
13. Почему не рекомендуются множественные конкатенации `String`?
14. Разница между `String`, `StringBuilder` (Java 1.5) и `StringBuffer`(Java 1.0)?
15. Что такое массив, какие на нём есть ограничения?
16. Существуют ли многомерные массивы в java? Как создать многомерный массив?
17. Что такое метод и чем отличается от функции, возвращаемое значение, аргументы метода?
18. Что такое инкремент и декремент?
19. Чем отличаются постфиксная и префиксная форма?
20. Какие есть логические операции?
21. А если подряд три true XOR true XOR true какой результат?
22. Расскажи про все условные операторы?
23. Можно ли в switch case использовать String, Enum?
24. Какие есть циклы в Java? Чем отличаются друг от друга? (пост условие пред условие)
25. Что такое continue и break? Почему не рекомендуется их использовать?
26. Если в case не поставить break что будет?
27. Что такое рекурсия? Недостатки и преимущества?
28. Зачем нужны BigInteger и BigDecimal?

## ООП

1. Что такое ООП? В чем его плюсы?
2. Перечислите основные принципы ООП (3 штуки) без объяснений?
3. Что такое инкапсуляция? Приведите пример инкапсуляции?
4. Что такое полиморфизм? Приведите пример полиморфизма?
5. Что такое наследование? Приведите пример наследования? Зачем оно нужно?
6. Что такое класс? Объект?
7. Передача параметров по ссылке или по значению?
8. Как передаются объекты в метод?
9. Что будет если передать массив в метод, который изменит его значения, изменятся ли они вне метода? Почему? А если
   передать примитив?
10. Что такое переопределение метода в Java?
11. Что такое перегрузка метода в Java?
12. Что такое нативные методы, их плюсы и минусы?
13. Перечислите все модификаторы доступа в порядке уменьшения закрытости, какую область видимости они имеют?
14. Какие модификаторы доступа могут быть у класса?
15. Что такое final?
16. Что может быть final? Как они работают?
17. Как реализована неизменность String?
18. Как реализовать свой Immutable тип данных?
19. Что такое ключевое слово static? Что может быть static? Можно ли использовать статические методы в обычных?
    Наоборот? Почему?
20. Может ли статический метод быть перегружен?
21. Будет ли работать переопределение статического метода?
22. Могут ли нестатические методы перегрузить статические?
23. Что такое пакет? Как создать пакет?
24. Что такое конструкторы? Конструктор по-умолчанию?
25. Будет ли в классе конструктор и какой, если при его создании ни один не был задан?
26. Будет ли создан автоматически конструктор по-умолчанию, если в созданном классе есть любой другой конструктор?
27. Можно ли в классе вызвать один конструктор из другого? Как это сделать?
28. Как вызвать конструктор родителя?
29. Расскажи, что такое this и super? Когда мы обязаны использовать this и super?
30. Класс Object, все методы кроме wait, notify, notifyAll, назвать и объяснить, как работают
31. Зачем нужен метод finalize?
32. Назовите контракт между equals и hashcode? Из-за чего происходят коллизии?
33. Почему нельзя написать hashcode гарантировано без коллизий?
34. В чём разница между instanceOf и getClass?
35. Перечислите методы именно класса Enum?
36. Что такое интерфейс? Когда использовать интерфейс? Можно ли создать поля в интерфейсе?
37. Есть ли в Java множественное наследование классов?
38. Что дает множественная реализация интерфейсов?
39. Зачем наследовать интерфейс интерфейсу?
40. Можно ли создавать статик методы в интерфейсах?
41. Что такое абстрактный метод?
42. Что такое абстрактный класс? Чем отличается от обычного?
43. Может ли быть абстрактный класс без абстрактных методов?
44. Может ли быть конструктор у абстрактного класса? Для чего?
45. Синтаксические отличия интерфейса от абстрактного класса (АК)? 5 отличий

## Коллекции

1. Что такое коллекции (`Collection`) в Java? Какие основные интерфейсы коллекций вы знаете? Нарисуйте иерархию классов
   коллекций.
2. В чем разница между `List`, `Set` и `Map`?
3. Что такое `ArrayList`? В чем разница между `ArrayList` и `LinkedList`?
4. Что такое `HashMap`? Какие основные методы доступа и модификации данных в `HashMap`?
5. Что такое `HashSet`? Какая особенность у HashSet в отношении дубликатов и порядка элементов?
6. Что такое итератор (`Iterator`)? Как его использовать для перебора элементов коллекции?
7. Какие коллекции из Java Collections Framework потокобезопасны (thread-safe) по умолчанию?
8. Что такое ConcurrentHashMap? В чем его отличие от HashMap?
9. Что такое синхронизированные (synchronized) коллекции? Какие есть синхронизированные реализации в Java?
10. Как можно сортировать элементы в коллекциях? Какой интерфейс следует использовать для сортировки?

## Исключения

1. Что такое исключение (`Exception`) в Java? Какие проблемы они помогают обрабатывать?
2. Нарисуйте иерархию исключений.
3. Чем отличается checked исключение от unchecked исключения?
4. Назовите знакомые вам исключения и когда они могут возникнуть.
5. Что такое try-with-resources? Как его использовать для автоматического закрытия ресурсов?
6. Что произойдет с исключением, выкинутым из блока finally?

## Threads

1. Что такое поток (`Thread`) в Java?
2. В чем отличие потока (`Thread`) от процесса (`Process`)?
3. Как создать новый поток?
4. Что значит и для чего используется ключевое слово `final`?
5. Что значит и для чего используется ключевое слово `volatile`? Как оно влияет на работу с переменными в многопоточной
   среде?
6. Что значит и для чего используется ключевое слово `synchronized`?
7. Что такое монитор?
8. Какие методы класса Object используются для синхронизации и ожидания потоков?
9. Что такое wait() и notify() методы? Как они используются для синхронизации потоков?
10. Что такое взаимная блокировка (deadlock)? Как она возникает и как ее избежать?
11. Что вы знаете о пакете `java.util.concurrent`?

## Ответы

### 1. Какие есть примитивные типы и какие у них размеры?

| Тип данных | Размер в байтах | Размер в битах | Диапазон значений                                          |
|------------|-----------------|----------------|------------------------------------------------------------|
| byte       | 1               | 8              | -128 до 127                                                |
| short      | 2               | 16             | -32,768 до 32,767                                          |
| int        | 4               | 32             | -2,147,483,648 до 2,147,483,647                            |
| long       | 8               | 64             | -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807    |
| float      | 4               | 32             | Приблизительно ±3.40282347E+38 (6-7 значащих цифр)         |
| double     | 8               | 64             | Приблизительно ±1.7976931348623157E+308 (15 значащих цифр) |
| char       | 2               | 16             | 0 до 65,535 (включая полный набор Unicode символов)        |
| boolean    | 1               | 8              | true или false                                             |

### 2. Почему 0.1 + 0.7 != 0.8? (float 0.9+0.7 считает с погрешностью, double почти все)

Для хранения чисел с дробной частью в компьютерах
используется [Двоичная система с плавающей запятой](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D1%81_%D0%BF%D0%BB%D0%B0%D0%B2%D0%B0%D1%8E%D1%89%D0%B5%D0%B9_%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%BE%D0%B9).
В Java для этого используются типы данных `float` и `double`, однако, из-за ограниченного количества бит для
представления чисел, некоторые дробные значения не могут быть точно представлены, что может приводить к неточным
результатам при арифметических операциях. Чтобы избежать проблем с точностью, рекомендуется
использовать класс `BigDecimal` или сравнивать числа с маленькой допустимой погрешностью вместо проверки на точное
равенство.

### 3. Что такое char? Почему над ним можно выполнять арифметические операции?

`char` - это примитивный числовой тип данных, который используется для представления одного
символа [Unicode](https://en.wikipedia.org/wiki/Unicode). По сути, каждый символ `Unicode` представляется числовым
значением, поэтому выполнять арифметические операции с `char` возможно.
Пример:

```java
class Example {
    public static void main(String[] args) {
        char ch1 = 'a'; // числовое значение 97
        char ch2 = 'b'; // числовое значение 98
        char result = (char) (ch1 + ch2); // числовое значение 97 + 98 = 195
    }
}
```

### 4. Какие есть виды приведения типов?

- Неявное (автоматическое) приведение типов. Происходит автоматически, когда значение одного типа данных присваивается
  переменной другого типа с большим диапазоном значений. Например, присваивание int (4 байта) переменной типа double (8
  байт).

```java
class Example {
    public static void main(String[] args) {
        // Пример 1
        int x = 10;
        double y = x; // Неявное приведение int к double

        // Пример 2 
        float a = 3.14f;
        double b = a; // Неявное приведение float к double
    }
}
```

- Явное (ручное) приведение типов: Происходит вручную, когда мы явно указываем, что хотим преобразовать
  из одного типа в другой. При явном приведение типов может происходить потеря данных.

```java
class Example {
    public static void main(String[] args) {
        // Пример 1
        double c = 7.65;
        int d = (int) c; // Явное приведение double к int, дробная часть будет отброшена


        // Пример 2
        int e = 130;
        byte f = (byte) e; // Явное приведение int к byte, возможна потеря данных из-за переполнения
    }
}
```

### 5. В каком случае компилятор не может сделать приведение сам и просит сделать приведение программиста?

Компилятор может выполнять неявное (автоматическое) приведение типов, когда оно безопасно и не приводит к потере данных.

- Преобразование из типа с большим диапазоном к типу с меньшим диапазоном. Например, преобразование `double` к `int`,
  что
  может привести к потере дробной части.
- Преобразование между различными типами данных, например, преобразование `float` к `int`.
- Передача аргументов методам с различными типами. Если типы аргументов метода не совпадают с типами параметров,
  требуется явное приведение.

### 6. Какие есть классы-обертки?

Для каждого примитивного типа данных в Java есть обертка, которая позволяют превратить его в объект

| Примитивный тип данных | Обертка   |
|------------------------|-----------|
| byte                   | Byte      |             
| short                  | Short     |             
| int                    | Integer   |             
| long                   | Long      |             
| float                  | Float     |             
| double                 | Double    |    
| char                   | Character |    
| boolean                | Boolean   |

### 7. Зачем нужны классы-обертки? Immutable ли обертки?

Обертки позволяют нам работать с примитивными типами данных как с объектами. Это особенно полезно, когда мы
работаем с классами из пакета `java.util.Collections`, которые могут хранить только объекты, а не примитивные типы.

Обертки являются неизменяемыми (immutable), так что каждый раз создается новый объект.

### 8. Что такое unboxing(распаковка), autoboxing(автоупаковка) в обертках.

Unboxing(распаковка) и autoboxing(автоупаковка) - это процессы автоматического преобразования между примитивными типами
и соответствующими обертками, благодаря которым мы можем бесшовно использоваться обертки и примитивы.

- Autoboxing (автоупаковка) - процесс автоматического преобразования из примитива в обертку.
- Unboxing (распаковка) - процесс автоматического преобразования обертки обратно в примитивный тип.

```java
class Example {
    public static void main(String[] args) {
        int a = 42;

        Integer wrappedA = a; // Автоупаковка, int преобразуется в Integer

        int b = wrappedA; // Распаковка, Integer преобразуется в int
    }
}
```

### 9. Если при распаковке обертка была равна `null`, произойдет исключение `java.lang.NullPointerException`?

Да, мы получим `NPE`, поскольку мы получим `null` при распаковке, а примитивные типы данных не могут быть равны `null`.

### 10. Может ли примитив быть `null`? Что такое литерал?

Примитивные типы данных не могут быть равны `null`.
Литералы - это **константные** значения, которые находятся в коде и не меняются во время работы программы.

### 11. Что такое `String Pool` (пул строк) и `Primitive Pool` (пул примитивов)?

Пул строк и пул примитивов - это механизм в Java используемый для оптимизации использования памяти и повышения
производительности, за счет использования уже существующих значений, вместо создания новых.

Пример для `String Pool`:

```java
class Example {
    public static void main(String[] args) {
        String str1 = "Hello"; // Строка добавляется в String Pool
        String str2 = "Hello"; // Используется уже существующая ссылка из String Pool
        String str3 = new String("Hello"); // Не добавляется в String Pool, создается новый объект

        System.out.println(str1 == str2); // true, так как используется ссылка из String Pool
        System.out.println(str1 == str3); // false, так как мы создали новый объект str3
    }
}
```

`Primitive Pool`:
Стоит отметить, что в Primitive Pool сохраняются не все примитивные типы.
`long`,`float`, `double` не сохраняются в Primitive Pool.

| Примитивный тип данных | Диапазон который сохраняется в Pool                        |
|------------------------|------------------------------------------------------------|
| byte                   | -128 до 127                                                |             
| short                  | -128 до 127                                                |             
| int                    | -128 до 127                                                |              
| char                   | '\u0000' (нулевой символ) до '\u007F' (символ с кодом 127) |    
| boolean                | true и false                                               |

### 12. Integer a = 100; Integer b = 100; System.out.println(b == a); Какой результат будет?

Результат будет `true`, поскольку 100 входит в диапазон значений для Primitive Pool.

```java
class Example {
    public static void main(String[] args) {
        Integer a = 100;
        Integer b = 100;
        System.out.println(a == b); // true

        Integer c = 1000;
        Integer d = 1000;
        System.out.println(c == d); // false
    }
}
```

### 13. Почему не рекомендуются множественные конкатенации `String`?

В Java String являются неизменяемыми объектами, что означает, что каждая операция сложения будет создавать новую строку.
Вместо простого сложения большого количества строк лучше иcпользовать `StringBuilder`.

```java
class Example {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        sb.append("Hello");
        sb.append(" ");
        sb.append("World");
        String result = sb.toString();
        System.out.println(result);
    }
}
```

### 14. Разница между `String`, `StringBuilder` (Java 1.5) и `StringBuffer`(Java 1.0)?

`String` - это неизменяемый класс, из-за чего при его изменении (конкатенация, создание подстроки итд) каждый раз
создается новая строка.

`StringBuilder` - это изменяемый класс, который позволяет изменять строку без создания новых строк. Так же предоставляет
методы для изменения, добавления и удаления символов или подстрок в строке, что делает его более эффективным при
множественных изменениях строки.

`StringBuffer` - это потоко-безопасный (thread-safe) аналог `StringBuilder`.

### 15. Что такое массив, какие на нём есть ограничения?

Массив - это структура данных, которая представляет собой упорядоченную коллекцию элементов одного типа. Элементы
массива расположены в памяти последовательно.

Ограничения массивов:

1. Фиксированный размер. Размер массива определяется в момент его создания и не может изменяться в дальнейшем
2. Один тип данных. Массив может содержать элементы только одного типа данных.
3. Индексация. Элементы массива нумеруются с нуля. Доступ к элементам осуществляется по их индексу, и выход за пределы
   массива может привести к ошибке `ArrayIndexOutOfBoundsException`.

### 16. Существуют ли многомерные массивы в java? Как создать многомерный массив?

Да, существуют. Многомерный массив - это собой массив массивов или, другими словами, это
массив, элементами которого также являются массивы. Наиболее распространенные многомерные массивы - это двумерные
массивы, но можно создавать массивы с большим числом измерений.

Пример создания многомерного массива:

```java
class Example {
    public static void main(String[] args) {
        // двумерный массив размером 3x4 (3 строки и 4 столбца).
        int[][] twoDimensionalArray = new int[3][4];

        // трехмерный массив размером 2x3x4 (2 блока, каждый из которых содержит 3 строки и 4 столбца).
        int[][][] threeDimensionalArray = new int[2][3][4];
    }
}
```

### 17. Что такое метод и чем отличается от функции, возвращаемое значение, аргументы метода?

Метод - это блок кода внутри класса, выполняющий определенную операцию или действие. Привязан к объектам класса.

Термин "функция" часто используется как синоним "метода", однако "функция" не привязана к объекту класса.

Возвращаемое значение - это значение, которое метод возвращает после выполнения операции.

Аргументы метода - это значения, переданные в метод при его вызове для использования внутри метода.

### 18. Что такое инкремент и декремент?

Инкремент и декремент - это унарные операции, которые увеличивают (инкремент) или уменьшают (декремент) значение
переменной на единицу.

```java
class Example {
    public static void main(String[] args) {

        // Инкремент
        int x = 5;
        x++; // Теперь x равно 6

        // Декремент
        int y = 10;
        y--; // Теперь y равно 9

    }
}
```

### 19. Чем отличаются постфиксная и префиксная форма?

Постфиксная и префиксная формы отличаются порядком выполнения операций, что произойдет раньше изменение значения или его
возврат.

- Постфиксная форма
    - Возврат значения переменной
    - Изменение значения переменной
- префиксная форма
    - Изменение значения переменной
    - Возврат значения переменной

```java
class Example {
    public static void main(String[] args) {

        // Постфиксная форма
        int x = 5;
        // Сначала мы присвоим значение x равное 5 в переменную resultX, а уже после мы увеличим его на 1
        // Результат: x=6 resultX=5
        int resultX = x++;


        // Префиксная форма
        int y = 10;
        // Сначала мы увеличим значение на 1 и получим y=11, а уже после мы присвоим значение y равное 11 в переменную resultY
        // Результат: y=11 resultY=11
        int resultY = ++y;
    }
}
```

### 20. Какие есть логические операции?

1. Логическое И (AND) записывается как (&&). Принимает значение `true` только если оба параметра являются
   истинными `true`. Таблица истинности:

| A     | B     | A && B |
|-------|-------|--------|
| true  | true  | true   |
| true  | false | false  |
| false | true  | false  |
| false | false | false  |

2. Логическое ИЛИ (OR) записывается как (||). Принимает значение `true` сли хотя бы один из параметров является
   истинным `true`. Таблица истинности:

| A     | B     | A \|\| B |
|-------|-------|----------|
| true  | true  | true     |
| true  | false | true     |
| false | true  | true     |
| false | false | false    |

3. Логическое НЕ (NOT) записывается как (!). Изменяет значение параметра на противоположное
   Таблица истинности:

| A     | !A    |
|-------|-------|
| true  | false |
| false | true  |

4. Исключающее ИЛИ (XOR) записывается как (^). Принимает значение `true` только если один параметр является
   истинным `true`. Таблица истинности:

| A     | B     | A ^ B |
|-------|-------|-------|
| true  | true  | false |
| true  | false | true  |
| false | true  | true  |
| false | false | false |

Вы можете скопировать и вставить этот код в свой файл формата Markdown для отображения таблицы истинности логических
операций.

### 21. А если подряд три true XOR true XOR true какой результат?

Результат будет true, поскольку `true XOR true = false`, а `false XOR true = true`.

```java
class Example {
    public static void main(String[] args) {
        boolean result = true ^ true ^ true;

        System.out.println("Результат выражения: " + result);
    }
}
```

### 22. Расскажи про все условные операторы?

В Java существуют три условных оператора `if`, `switch` и Тернарный оператор `?`.

1. Оператор `if` выполняет код если условие истинное, если же оно ложное, то выполняется код в блоке `else`, однако его
   может и не быть.
   Пример:

```java
class Example {
    public static void main(String[] args) {
        int x = 10;

        // If без else
        if (x > 0) {
            System.out.println("Число положительное");
        }

        // if-else
        if (x > 0) {
            System.out.println("Число положительное");
        } else {
            System.out.println("Число не положительное");
        }

        // несколько if-else
        if (x > 0) {
            System.out.println("Число положительное");
        } else if (x < 0) {
            System.out.println("Число отрицательное");
        } else {
            System.out.println("Число равно нулю");
        }
    }
}
```

2. Оператор `switch` может иметь несколько блоков кода, каждый из которых выполниться при определенном условии.

```java
class Example {
    public static void main(String[] args) {
        int dayOfWeek = 3;
        switch (dayOfWeek) {
            case 1:
                System.out.println("Понедельник");
                break;
            case 2:
                System.out.println("Вторник");
                break;
            case 3:
                System.out.println("Среда");
                break;
            default:
                System.out.println("День недели неизвестен");
        }

    }
}
```

3. Тернарный оператор `?` является упрощенной формой записи оператора `if-else`.
   Форма записи тернарного оператора: `условие ? значение_если_истина : значение_если_ложь`

```java
class Example {
    public static void main(String[] args) {
        int a = 10;
        int b = 5;
        int max = (a > b) ? a : b;
        System.out.println("Максимальное значение: " + max);
    }
}
```

### 23. Можно ли в switch case использовать String, Enum?

Да, в switch case можно использовать строки и перечисления.

Пример со строкой:

```java
class Example {
    public static void main(String[] args) {
        String dayOfWeek = "Monday";
        switch (dayOfWeek) {
            case "Monday":
                System.out.println("Понедельник");
                break;
            case "Tuesday":
                System.out.println("Вторник");
                break;
            // ... другие варианты дней недели ...
            default:
                System.out.println("День недели неизвестен");
        }

    }
}
```

Пример с перечислением:

```java
class Example {
    public static void main(String[] args) {
        enum Color {
            RED, GREEN, BLUE;
        }

        Color color = Color.RED;
        switch (color) {
            case RED:
                System.out.println("Красный");
                break;
            case GREEN:
                System.out.println("Зеленый");
                break;
            case BLUE:
                System.out.println("Синий");
                break;
            default:
                System.out.println("Цвет неизвестен");
        }
    }
}
```

### 24. Какие есть циклы в Java? Чем отличаются друг от друга? (пост условие пред условие)

1. Цикл `for` используется для выполнения блока кода заданное количество раз.
   Синтаксис:

```java
for(инициализация;условие;операци после итерации){
        // Блок кода, который будет выполняться
        }
```

2. Цикл `while`, используется для выполнения блока кода, пока заданное условие истинно.
   Синтаксис:

```java
while(условие){
        // Блок кода, который будет выполняться
        }
```

3. Цикл `do-while` похож на цикл "while", но проверка условия происходит после каждой итерации, поэтому блок кода
   выполняется хотя бы один раз, даже если условие изначально ложно.
   Синтаксис:

```java
do{
        // Блок кода, который будет выполняться
        }while(условие);
```

### 25. Что такое continue и break? Почему не рекомендуется их использовать?

`continue` и `break` - это управляющие операторы.
Рекомендация: в некоторых случаях `continue` и `break` могут использоваться, однако нужно стараться избегать частого
их использования, поскольку они усложняют логику и затрудняют понимание кода.

1. `Continue` - используется в циклов (`for`, `while`, `do-while`), чтобы перейти к следующей итерации.

```java
class Example {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            if (i == 3) {
                continue; // Пропустить i = 3 и перейти к следующей итерации
            }
            System.out.println(i);
        }
        // Результат в консоли: 1, 2, 4, 5
    }
}
```

2. `Break` - используется в циклах и в `switch` для того, чтобы преждевременно выйти из него.

```java
class Example {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            if (i == 3) {
                break; // Завершить цикл, если i = 3
            }
            System.out.println(i);
        }
        // Результат в консоли: 1, 2
    }
}
```

### 26. Если в case не поставить break что будет?

Если не добавить `break` в конце `case`, то произойдет так называемое "проваливание (fall-through)" и начнет выполняться
следующий блок `case`.

```java
class Example {
    public static void main(String[] args) {
        int dayOfWeek = 3;
        switch (dayOfWeek) {
            case 1:
                System.out.println("Понедельник");
            case 2:
                System.out.println("Вторник");
            case 3:
                System.out.println("Среда");
            case 4:
                System.out.println("Четверг");
            case 5:
                System.out.println("Пятница");
            default:
                System.out.println("Выходные");

                // Результат в консоли:
                // Среда
                // Четверг
                // Пятница
                // Выходные
        }
    }
}
```

### 27. Что такое рекурсия? Недостатки и преимущества?

Рекурсия - это техника в программировании, при которой функция вызывает саму себя. Это позволяет решать сложные задачи
шаг за шагом.
Хорошим примером рекурсии является решение задачи по вычислению факториала числа.

```java
class Example {
    public static void main(String[] args) {
        System.out.println(factorial(10)); // Результат: 3628800
    }

    static int factorial(int n) {
        if (n == 0 || n == 1) {
            return 1;
        } else {
            return n * factorial(n - 1);
        }
    }

}
```

Преимущества:

1. Позволяет решать сложные задачи постепенно через разбиение на простые подзадачи.
2. Удобство решения. Решение некоторых задач очень удобно можно представить в рекурсивной форме, к примеру обход
   деревьев или графов.
3. В некоторых ситуациях, рекурсия может быть более эффективной чем итеративные подходы.

Недостатки

1. Потенциальная переполнение стека. Каждый рекурсивный вызов добавляется в стек, так как что если рекурсия слишком
   глубокая, то может произойти переполнение стека с ошибкой `StackOverflowError`.
2. Рекурсия может проигрывать итеративным подходам за счет дополнительных расходов на управление стеком вызовов.
3. Рекурсивные функции сложны для отладки, из-за того, что мы постоянно делаем вложенные вызовы.

### 28. Зачем нужны BigInteger и BigDecimal?

`BigInteger` и `BigDecimal` нужны для того, чтобы работать с числами, которые не помещаются в примитивные типы данных.
`BigInteger` позволяет работать с целыми числами произвольной длины числами
`BigDecimal`позволяет работать с плавающей запятой произвольной точности.